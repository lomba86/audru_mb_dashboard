/*!
 * async-af/legacy v7.0.39
 * 
 * AsyncAF (The asynciest of async libs there ever was or ever will be...AsyncAF!?) 
 * (https://async-af.js.org/AsyncAF)
 * 
 * Copyright (c) 2017-present, Scott Rudiger (https://github.com/ScottRudiger)
 * 
 * This source code is licensed under the MIT license found in this library's
 * GitHub repository (https://github.com/AsyncAF/AsyncAF/blob/master/LICENSE).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("AsyncAF", [], factory);
	else if(typeof exports === 'object')
		exports["AsyncAF"] = factory();
	else
		root["AsyncAF"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./lib/classes/AsyncAF.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./lib/classes/AsyncAF.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/defineProperty.js
var defineProperty = __webpack_require__("./node_modules/@babel/runtime/helpers/defineProperty.js");
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js
var taggedTemplateLiteral = __webpack_require__("./node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js");
var taggedTemplateLiteral_default = /*#__PURE__*/__webpack_require__.n(taggedTemplateLiteral);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/slicedToArray.js
var slicedToArray = __webpack_require__("./node_modules/@babel/runtime/helpers/slicedToArray.js");
var slicedToArray_default = /*#__PURE__*/__webpack_require__.n(slicedToArray);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/classCallCheck.js
var classCallCheck = __webpack_require__("./node_modules/@babel/runtime/helpers/classCallCheck.js");
var classCallCheck_default = /*#__PURE__*/__webpack_require__.n(classCallCheck);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js
var possibleConstructorReturn = __webpack_require__("./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");
var possibleConstructorReturn_default = /*#__PURE__*/__webpack_require__.n(possibleConstructorReturn);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/getPrototypeOf.js
var getPrototypeOf = __webpack_require__("./node_modules/@babel/runtime/helpers/getPrototypeOf.js");
var getPrototypeOf_default = /*#__PURE__*/__webpack_require__.n(getPrototypeOf);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/inherits.js
var inherits = __webpack_require__("./node_modules/@babel/runtime/helpers/inherits.js");
var inherits_default = /*#__PURE__*/__webpack_require__.n(inherits);

// EXTERNAL MODULE: ./lib/methods/_internal/createNewlessClass.js
var createNewlessClass = __webpack_require__("./lib/methods/_internal/createNewlessClass.js");

// EXTERNAL MODULE: ./lib/classes/AsyncAfWrapper.js + 2 modules
var AsyncAfWrapper = __webpack_require__("./lib/classes/AsyncAfWrapper.js");

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/toConsumableArray.js
var toConsumableArray = __webpack_require__("./node_modules/@babel/runtime/helpers/toConsumableArray.js");
var toConsumableArray_default = /*#__PURE__*/__webpack_require__.n(toConsumableArray);

// EXTERNAL MODULE: ./lib/methods/_internal/nameFunction.js
var nameFunction = __webpack_require__("./lib/methods/_internal/nameFunction.js");

// EXTERNAL MODULE: ./lib/methods/other/logAF.js + 4 modules
var logAF = __webpack_require__("./lib/methods/other/logAF.js");

// EXTERNAL MODULE: ./lib/methods/arrays/mapAF.js
var mapAF = __webpack_require__("./lib/methods/arrays/mapAF.js");

// EXTERNAL MODULE: ./lib/methods/arrays/forEachAF.js
var forEachAF = __webpack_require__("./lib/methods/arrays/forEachAF.js");

// EXTERNAL MODULE: ./lib/methods/arrays/filterAF.js
var filterAF = __webpack_require__("./lib/methods/arrays/filterAF.js");

// EXTERNAL MODULE: ./lib/methods/arrays/reduceAF.js + 1 modules
var reduceAF = __webpack_require__("./lib/methods/arrays/reduceAF.js");

// EXTERNAL MODULE: ./lib/methods/arrays/everyAF.js
var everyAF = __webpack_require__("./lib/methods/arrays/everyAF.js");

// EXTERNAL MODULE: ./lib/methods/arrays/someAF.js
var someAF = __webpack_require__("./lib/methods/arrays/someAF.js");

// EXTERNAL MODULE: ./lib/methods/arrays/includesAF.js
var includesAF = __webpack_require__("./lib/methods/arrays/includesAF.js");

// EXTERNAL MODULE: ./lib/methods/arrays/findAF.js
var findAF = __webpack_require__("./lib/methods/arrays/findAF.js");

// EXTERNAL MODULE: ./lib/methods/arrays/findIndexAF.js
var findIndexAF = __webpack_require__("./lib/methods/arrays/findIndexAF.js");

// EXTERNAL MODULE: ./lib/methods/arrays/indexOfAF.js
var indexOfAF = __webpack_require__("./lib/methods/arrays/indexOfAF.js");

// EXTERNAL MODULE: ./lib/methods/arrays/lastIndexOfAF.js
var lastIndexOfAF = __webpack_require__("./lib/methods/arrays/lastIndexOfAF.js");

// EXTERNAL MODULE: ./lib/methods/arrays/joinAF.js
var joinAF = __webpack_require__("./lib/methods/arrays/joinAF.js");

// EXTERNAL MODULE: ./lib/methods/arrays/concatAF.js
var concatAF = __webpack_require__("./lib/methods/arrays/concatAF.js");

// EXTERNAL MODULE: ./lib/methods/strings/splitAF.js
var splitAF = __webpack_require__("./lib/methods/strings/splitAF.js");

// CONCATENATED MODULE: ./packageList.js



/* eslint-disable import/first */

var libName = 'async-af';
var libPath = './lib/';

var makeScoped = function makeScoped(name) {
  return "@".concat(libName, "/").concat(name.replace(/AsyncAf|AF/g, '').toLowerCase());
};
/* ____________________________
  |           CLASSES          |
  |____________________________| */


var classPath = "".concat(libPath, "classes/");
var classes = [[{
  name: 'AsyncAF'
}, "".concat(classPath, "AsyncAF"), libName], [{
  name: 'AsyncAfWrapper'
}, "".concat(classPath, "AsyncAfWrapper"), makeScoped('AsyncAfWrapper')]];
/* ____________________________
  |       STATIC METHODS       |
  |____________________________| */


var staticMethods = [Object(nameFunction["default"])(logAF["default"], 'logAF')].map(function (method) {
  return [method, "".concat(libPath, "methods/other/").concat(method.name), makeScoped(method.name)];
});
/* ____________________________
  |      PROTOTYPE METHODS     |
  |____________________________| */
// Arrays














var arrayMethods = [Object(nameFunction["default"])(mapAF["default"], 'mapAF'), Object(nameFunction["default"])(forEachAF["default"], 'forEachAF'), Object(nameFunction["default"])(filterAF["default"], 'filterAF'), Object(nameFunction["default"])(reduceAF["default"], 'reduceAF'), Object(nameFunction["default"])(everyAF["default"], 'everyAF'), Object(nameFunction["default"])(someAF["default"], 'someAF'), Object(nameFunction["default"])(includesAF["default"], 'includesAF'), Object(nameFunction["default"])(findAF["default"], 'findAF'), Object(nameFunction["default"])(findIndexAF["default"], 'findIndexAF'), Object(nameFunction["default"])(indexOfAF["default"], 'indexOfAF'), Object(nameFunction["default"])(lastIndexOfAF["default"], 'lastIndexOfAF'), Object(nameFunction["default"])(joinAF["default"], 'joinAF'), Object(nameFunction["default"])(concatAF["default"], 'concatAF')].map(function (method) {
  return [method, "".concat(libPath, "methods/arrays/").concat(method.name), makeScoped(method.name)];
}); // strings


var stringMethods = [Object(nameFunction["default"])(splitAF["default"], 'splitAF')].map(function (method) {
  return [method, "".concat(libPath, "methods/strings/").concat(method.name), makeScoped(method.name)];
});
var prototypeMethods = [].concat(toConsumableArray_default()(arrayMethods), toConsumableArray_default()(stringMethods));
/* ____________________________
  |         COLLECTIONS        |
  |____________________________| */
// import arrays from './lib/collections/arrays';

var collections = [// arrays,
];
/* harmony default export */ var packageList = ([].concat(classes, toConsumableArray_default()(staticMethods), toConsumableArray_default()(prototypeMethods), collections));

var packageList_pluckMethods = function pluckMethods(packages) {
  return packages.map(function (_ref) {
    var _ref2 = slicedToArray_default()(_ref, 1),
        method = _ref2[0];

    return method;
  });
};

var staticMethodsOnly = packageList_pluckMethods(staticMethods);
var prototypeMethodsOnly = packageList_pluckMethods(prototypeMethods);

// CONCATENATED MODULE: ./lib/classes/AsyncAF.js








function _templateObject() {
  var data = taggedTemplateLiteral_default()(["AF"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}




/**
 * class that holds all the AsyncAF methods
 *
 * while AsyncAF is a class, it can create instances with or without the `new` keyword
 * @param {any} data the data to be wrapped by the AsyncAF class; can be promises or non-promises
 * @returns {Object} returns an instance of AsyncAF wrapping the passed in data
 * @example
 *
 * const promises = [1, 2, 3].map(n => Promise.resolve(n));
 *
 *
 * AsyncAF(promises).mapAF(n => n * 2).filterAF(n => n !== 4).forEachAF(n => console.log(n));
 * // logs 2 then 6
 * @since 3.0.0
 * @see AsyncAfWrapper
 * @class AsyncAF
 */

var AsyncAF_AsyncAF = Object(createNewlessClass["default"])(
/*#__PURE__*/
function (_AsyncAfProto) {
  inherits_default()(AsyncAF, _AsyncAfProto);

  function AsyncAF() {
    classCallCheck_default()(this, AsyncAF);

    return possibleConstructorReturn_default()(this, getPrototypeOf_default()(AsyncAF).apply(this, arguments));
  }

  return AsyncAF;
}(AsyncAfWrapper["AsyncAfWrapperProto"]));

var AsyncAF_prepForDefine = function prepForDefine(methods) {
  return methods.reduce(function (methods, method) {
    // add all '*AF' methods and add 'AF-less' aliases (e.g., mapAF -> map)
    var _ref = method.name.split(_templateObject()) ||
    /* istanbul ignore next */
    [method.name],
        _ref2 = slicedToArray_default()(_ref, 1),
        alias = _ref2[0];

    return Object.assign(methods, defineProperty_default()({}, method.name, {
      value: method
    }), defineProperty_default()({}, alias, {
      value: method
    }));
  }, {});
};

Object.defineProperties(AsyncAfWrapper["AsyncAfWrapperProto"], AsyncAF_prepForDefine(staticMethodsOnly));
Object.defineProperties(AsyncAfWrapper["AsyncAfWrapperProto"].prototype, AsyncAF_prepForDefine(prototypeMethodsOnly));
/* harmony default export */ var classes_AsyncAF = __webpack_exports__["default"] = (AsyncAF_AsyncAF);

/***/ }),

/***/ "./lib/classes/AsyncAfWrapper.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js
var possibleConstructorReturn = __webpack_require__("./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");
var possibleConstructorReturn_default = /*#__PURE__*/__webpack_require__.n(possibleConstructorReturn);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/getPrototypeOf.js
var getPrototypeOf = __webpack_require__("./node_modules/@babel/runtime/helpers/getPrototypeOf.js");
var getPrototypeOf_default = /*#__PURE__*/__webpack_require__.n(getPrototypeOf);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/inherits.js
var inherits = __webpack_require__("./node_modules/@babel/runtime/helpers/inherits.js");
var inherits_default = /*#__PURE__*/__webpack_require__.n(inherits);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/defineProperty.js
var defineProperty = __webpack_require__("./node_modules/@babel/runtime/helpers/defineProperty.js");
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/objectSpread.js
var objectSpread = __webpack_require__("./node_modules/@babel/runtime/helpers/objectSpread.js");
var objectSpread_default = /*#__PURE__*/__webpack_require__.n(objectSpread);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/classCallCheck.js
var classCallCheck = __webpack_require__("./node_modules/@babel/runtime/helpers/classCallCheck.js");
var classCallCheck_default = /*#__PURE__*/__webpack_require__.n(classCallCheck);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/createClass.js
var createClass = __webpack_require__("./node_modules/@babel/runtime/helpers/createClass.js");
var createClass_default = /*#__PURE__*/__webpack_require__.n(createClass);

// EXTERNAL MODULE: ./lib/methods/_internal/createNewlessClass.js
var createNewlessClass = __webpack_require__("./lib/methods/_internal/createNewlessClass.js");

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/typeof.js
var helpers_typeof = __webpack_require__("./node_modules/@babel/runtime/helpers/typeof.js");
var typeof_default = /*#__PURE__*/__webpack_require__.n(helpers_typeof);

// CONCATENATED MODULE: ./lib/methods/other/use.js


/**
 * adds prototype/static methods to AsyncAF or AsyncAfWrapper
 *
 * see {@link AsyncAfWrapper AsyncAfWrapper} for an example of how to cherry-pick AsyncAF methods you'd like to use rather than pulling in the entire AsyncAF library;
 *
 * for something different, the following shows how to add custom methods to AsyncAF & AsyncAfWrapper
 *
 * **Example**
 *
 * say you want to extend AsyncAF with your own prototype method that acts on an array of numbers or promises that resolve to numbers and naively adds them up
 *
 * let's call it sumAF; here's some code:
 *
 * ```js
 * // sumAF.js
 *
 * const sumAF = function () {
 *   return this.then(nums => Promise.all(nums))
 *     .then(nums => nums.reduce((sum, num) => sum + num));
 * };
 *
 * export default sumAF;
 * ```
 *
 * pull in {@link AsyncAF AsyncAF} or {@link AsyncAfWrapper AsyncAfWrapper} and `sumAF` to the file you'd like to use it in:
 *
 * ```js
 * // otherFile.js
 *
 * import AsyncAF from 'async-af'; // or import AsyncAF from '@async-af/wrapper';
 * import sumAF from './sumAF';
 * ```
 *
 * then, call `use` on `AsyncAF` and pass in `sumAF` wrapped in an object to the first parameter, `prototypeMethods`:
 *
 * ```js
 * // otherFile.js
 * // ...
 *
 * AsyncAF.use({sumAF});
 * ```
 *
 * ready! now your custom prototype method will be available on AsyncAF
 *
 * ```js
 * // otherFile.js
 * // ...
 *
 * const promises = [1, 2, 3].map(n => Promise.resolve(n));
 *
 * const sum = AsyncAF(promises).sumAF()
 *
 * AsyncAF.logAF(sum);
 * // @otherFile.js:10:9:
 * //  6
 * // in 0.001 secs
 * ```
 *
 * if you'd like to add a static method to AsyncAF, `use` accepts a second optional argument `staticMethods`; for example:
 *
 * ```js
 * const staticNoop = () => {};
 *
 * AsyncAF.use({}, {staticNoop});
 *
 * AsyncAF.staticNoop(); // noop
 * ```
 *
 * @static
 * @param {Object} prototypeMethods an Object containing the prototype methods you'd like to use
 * @param {Object=} staticMethods an Object containing the static methods you'd like to use
 * @returns {undefined} adds prototype/static methods to AsyncAF or AsyncAfWrapper
 * @since 3.0.0
 * @see AsyncAF
 * @see AsyncAfWrapper
 * @see {@tutorial TOO_MANY_IMPORTS}
 * @memberof AsyncAfWrapper
 * @alias AsyncAfWrapper#use
 */
var use_use = function use(prototypeMethods) {
  var staticMethods = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (typeof_default()(prototypeMethods) !== 'object') throw TypeError('prototypeMethods param accepts an Object containing the prototypeMethods you\'d like to add to the AsyncAF prototype, or an empty Object');
  if (typeof_default()(staticMethods) !== 'object') throw TypeError('staticMethods param accepts an Object containing the staticMethods you\'d like to add to AsyncAF');
  Object.assign(this.prototype, prototypeMethods);
  Object.assign(this, staticMethods);
};

/* harmony default export */ var other_use = (use_use);
// CONCATENATED MODULE: ./lib/methods/other/series.js
var inSeries = new WeakMap();
var series = {
  inSeries: {
    get: function get() {
      return inSeries.get(this);
    }
  },

  /**
   * indicates that the next method invoked should be performed in series
   *
   * when you need to perform a method in series rather than in parallel, prepend the method with `series`; e.g.:
   * ```js
   * AsyncAF(promises).series.forEachAF(callback)
   * ```
   *
   * `series` can currently be chained with:
   * - {@link AsyncAF#everyAF everyAF}
   * - {@link AsyncAF#filterAF filterAF}
   * - {@link AsyncAF#findAF findAF}
   * - {@link AsyncAF#findIndexAF findIndexAF}
   * - {@link AsyncAF#forEachAF forEachAF}
   * - {@link AsyncAF#includesAF includesAF}
   * - {@link AsyncAF#indexOfAF indexOfAF}
   * - {@link AsyncAF#lastIndexOfAF lastIndexOfAF}
   * - {@link AsyncAF#mapAF mapAF}
   * - {@link AsyncAF#reduceAF reduceAF}
   * - {@link AsyncAF#someAF someAF}
   *
   * @example
   * import delay from 'delay'; // {@link https://www.npmjs.com/package/delay}
   *
   * const nums = [2, 1];
   *
   * // perform a serial forEach by chaining {@link AsyncAF#series series} and {@link AsyncAF#forEachAF forEachAF}
   * (async () => {
   *   const start = Date.now();
   *
   *   await AsyncAF(nums).series.forEachAF(async num => {
   *     await delay(num * 1000);
   *     console.log(num, `at ~${Date.now() - start} ms`);
   *   });
   *
   *   console.log(`total: ~${Date.now() - start} ms`);
   * })();
   *
   * // logs:
   * // 2  'at ~2000 ms'
   * // 1  'at ~3000 ms'
   * // total: ~3000 ms
   *
   *
   * // perform a parallel forEach by omitting {@link AsyncAF#series series}
   * (async () => {
   *   const start = Date.now();
   *
   *   await AsyncAF(nums).forEachAF(async num => {
   *     await delay(num * 1000);
   *     console.log(num, `at ~${Date.now() - start} ms`);
   *   });
   *
   *   console.log(`total: ~${Date.now() - start} ms`);
   * })();
   *
   * // logs:
   * // 1  'at ~1000 ms'
   * // 2  'at ~2000 ms'
   * // total: ~2000 ms
   *
   * @function series
   * @returns {AsyncAF.<any>} returns an instance of AsyncAF that will perform the next method invocation serially
   * @since 7.0.0
   * @see {@link AsyncAF#io io} (alias)
   * @memberof AsyncAF#
   */
  series: {
    get: function get() {
      inSeries.set(this, !this.inSeries);
      return this;
    }
  },

  /**
   * `io` (in order) indicates that the next method invoked should be performed in series
   *
   * when you need to perform a method in series rather than in parallel, prepend the method with `io`; e.g.:
   * ```js
   * AsyncAF(promises).io.forEachAF(callback)
   * ```
   *
   * `io` is an alias for `series`; see {@link AsyncAF#series series's documentation} for more
   * @function io
   * @returns {AsyncAF.<any>} returns an instance of AsyncAF that will perform the next method invocation serially
   * @since 7.0.0
   * @see {@link AsyncAF#series series} (alias)
   * @memberof AsyncAF#
   */
  io: {
    get: function get() {
      return this.series;
    }
  }
};
/* harmony default export */ var other_series = (series);
// CONCATENATED MODULE: ./lib/classes/AsyncAfWrapper.js
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AsyncAfWrapperProto", function() { return AsyncAfWrapper_AsyncAfWrapperProto; });










var dataStore = new WeakMap();

var AsyncAfWrapper_AsyncAfWrapperProto =
/*#__PURE__*/
function () {
  function AsyncAfWrapperProto(data) {
    classCallCheck_default()(this, AsyncAfWrapperProto);

    dataStore.set(this, Promise.resolve(data));
  }

  createClass_default()(AsyncAfWrapperProto, [{
    key: "then",
    value: function then(resolve, reject) {
      return this.constructor(dataStore.get(this).then(resolve, reject));
    }
  }, {
    key: "catch",
    value: function _catch(reject) {
      return this.then(null, reject);
    }
  }, {
    key: "finally",
    value: function _finally(onFinally) {
      return dataStore.get(this).finally(onFinally);
    }
  }]);

  return AsyncAfWrapperProto;
}();

AsyncAfWrapper_AsyncAfWrapperProto.use = other_use;
Object.defineProperties(AsyncAfWrapper_AsyncAfWrapperProto.prototype, objectSpread_default()({}, other_series, defineProperty_default()({}, Symbol.toStringTag, {
  value: 'AsyncAF'
})));
/**
 * empty AsyncAF class wrapper
 *
 * AsyncAfWrapper is one option for cherry-picking only the methods you'd like to use in your code; {@link AsyncAfWrapper#use use}, {@link AsyncAF#series series}, and {@link AsyncAF#io io} are the only methods initially available on AsyncAfWrapper; see example below
 *
 * **Note:** while AsyncAfWrapper is a class, it can create instances with or without the `new` keyword
 *
 * **Example**
 *
 * say you only want to use {@link AsyncAF#mapAF mapAF}, {@link AsyncAF#filterAF filterAF}, {@link AsyncAF#forEachAF forEachAF}, and {@link AsyncAF#logAF logAF} instead of pulling in the entire AsyncAF library
 *
 * first, install the separate packages (e.g., for npm):
 *
 * `$ npm install --save @async-af/{wrapper,map,filter,foreach,log}`
 *
 * or, if on Windows:
 *
 * `$ npm install --save @async-af/wrapper @async-af/map @async-af/filter @async-af/foreach @async-af/log`
 *
 * then import the packages
 * ```js
 * import AsyncAF from '@async-af/wrapper'; // aliasing 'AsyncAfWrapper' as 'AsyncAF'
 * import mapAF from '@async-af/map';
 * import filterAF from '@async-af/filter';
 * import forEachAF from '@async-af/foreach';
 * import logAF from '@async-af/log';
 * ```
 *
 * _if you'd like to save some vertical screen real estate and cut the imports down to one line, see_ {@tutorial TOO_MANY_IMPORTS}
 *
 * then call {@link AsyncAfWrapper#use use}, including all prototype methods you'd like to add to AsyncAfWrapper's prototype in the first argument, `prototypeMethods` and all static methods you'd like to add to AsyncAfWrapper in the second optional argument, `staticMethods`
 * ```js
 * AsyncAF.use({ // prototype methods go in the first argument
 *   mapAF,
 *   filterAF,
 *   forEachAF
 * }, { // static methods go in the second argument
 *   logAF
 * });
 * ```
 *
 * ready to go!
 * ```js
 * const promises = [1, 2, 3].map(n => Promise.resolve(n));
 *
 * AsyncAF(promises).mapAF(n => n * 2).filterAF(n => n !== 4).forEachAF(n => console.log(n));
 * // logs 2 then 6
 *
 * AsyncAF.logAF(promises);
 * // @filename.js:24:9:
 * //  [ 1, 2, 3 ]
 * // in 0.003 secs
 * ```
 *
 * **protip:** you can use the same technique to add your own custom prototype or static methods to AsyncAfWrapper or even to the main AsyncAF class; see {@link AsyncAfWrapper#use use} for an example
 * @param {any} data the data to be wrapped by the AsyncAF class; can be promises or non-promises
 * @returns {Object} returns an instance of AsyncAfWrapper wrapping the passed in data
 * @since 3.0.0
 * @see AsyncAF
 * @see {@link AsyncAfWrapper#use use}
 * @see {@tutorial TOO_MANY_IMPORTS}
 * @class AsyncAfWrapper
 */

var AsyncAfWrapper_AsyncAfWrapper = Object(createNewlessClass["default"])(
/*#__PURE__*/
function (_AsyncAfWrapperProto) {
  inherits_default()(AsyncAfWrapper, _AsyncAfWrapperProto);

  function AsyncAfWrapper() {
    classCallCheck_default()(this, AsyncAfWrapper);

    return possibleConstructorReturn_default()(this, getPrototypeOf_default()(AsyncAfWrapper).apply(this, arguments));
  }

  return AsyncAfWrapper;
}(AsyncAfWrapper_AsyncAfWrapperProto));

/* harmony default export */ var classes_AsyncAfWrapper = __webpack_exports__["default"] = (AsyncAfWrapper_AsyncAfWrapper);

/***/ }),

/***/ "./lib/methods/_internal/commonCallback.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* eslint-disable no-unused-vars, valid-jsdoc */

/**
 * @typedef {callback} _
 * @param {?} currentValue
 * @param {Number=} index
 * @param {[]=} array
 * @returns {any}
 */
function callback(currentValue, index, array) {}

/* harmony default export */ __webpack_exports__["default"] = (callback);

/***/ }),

/***/ "./lib/methods/_internal/createNewlessClass.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_construct__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@babel/runtime/helpers/construct.js");
/* harmony import */ var _babel_runtime_helpers_construct__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_construct__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nameFunction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./lib/methods/_internal/nameFunction.js");



var createNewlessClass = function createNewlessClass(Class) {
  var name = Class.name;

  var Newless = function Newless() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _babel_runtime_helpers_construct__WEBPACK_IMPORTED_MODULE_0___default()(Class, args);
  };

  Newless.prototype = Class.prototype;
  Object.setPrototypeOf(Newless, Class);
  Newless.prototype.constructor = Newless;
  return Object(_nameFunction__WEBPACK_IMPORTED_MODULE_1__["default"])(Newless, name);
};

/* harmony default export */ __webpack_exports__["default"] = (createNewlessClass);

/***/ }),

/***/ "./lib/methods/_internal/nameFunction.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var nameFunction = function nameFunction(fn, name) {
  return Object.defineProperty(fn, 'name', {
    value: name,
    configurable: true
  });
};

/* harmony default export */ __webpack_exports__["default"] = (nameFunction);

/***/ }),

/***/ "./lib/methods/_internal/permissiveIsArrayLike.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var permissiveIsArrayLike = function permissiveIsArrayLike(obj) {
  return Array.isArray(obj) || obj != null && obj.length != null;
};

/* harmony default export */ __webpack_exports__["default"] = (permissiveIsArrayLike);

/***/ }),

/***/ "./lib/methods/_internal/promiseAllWithHoles.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var promiseAllWithHoles = function promiseAllWithHoles(promises) {
  return new Promise(function (resolve, reject) {
    var length = promises.length >>> 0;
    var result = Array(length);
    var pending = length;
    var i = length;
    if (!length) return resolve(result);

    var settlePromise = function settlePromise(i) {
      return Promise.resolve(promises[i]).then(function (value) {
        if (i in promises) result[i] = value;
        if (! --pending) resolve(result);
      }, reject);
    };

    while (i--) {
      settlePromise(i);
    }
  });
};

/* harmony default export */ __webpack_exports__["default"] = (promiseAllWithHoles);

/***/ }),

/***/ "./lib/methods/_internal/resolve.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "serial", function() { return serial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parallel", function() { return parallel; });
/* harmony import */ var _promiseAllWithHoles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./lib/methods/_internal/promiseAllWithHoles.js");


var serial = function serial(arr) {
  return function resolveSerially(resolved, i) {
    var length = resolved.length;
    if (!length) return Promise.resolve(resolved);
    var hole = !(i in arr);
    return Promise.resolve(arr[i]).then(function (el) {
      if (!hole) resolved[i] = el;
      if (i === length - 1) return resolved;
      return resolveSerially(resolved, i + 1);
    });
  }(Array(arr.length >>> 0), 0);
};

var parallel = function parallel(arr, mapper) {
  var thisArg = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
  return Object(_promiseAllWithHoles__WEBPACK_IMPORTED_MODULE_0__["default"])(arr, function (el) {
    return el;
  }).then(!mapper ? undefined : function (arr) {
    return Object(_promiseAllWithHoles__WEBPACK_IMPORTED_MODULE_0__["default"])(Array.prototype.map.call(arr, mapper, thisArg));
  });
};



/***/ }),

/***/ "./lib/methods/arrays/concatAF.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var resolveByType = function resolveByType(data) {
  return Promise[Array.isArray(data) ? 'all' : 'resolve'](data);
};
/**
 * merges an array or string with one or more arrays, strings, or other values, and resolves to a new array or string;
 *
 * concatAF flexibly accepts arrays, strings, promises, other values, or other instances of AsyncAF; see examples
 *
 * @param {any} values arrays, strings, or values to concatenate into a new array or string
 *  - if any values are a Promise, they'll first be resolved then concatenated
 *  - if any values are an instance of AsyncAF, they'll be merged into one instance
 * @returns {Promise.<Array>|Promise.<String>} `Promise` that resolves to a newly merged array or string
 * @example
 *
 * // arrays
 * const arr = Promise.resolve([1, 2]);
 * AsyncAF(arr).concatAF([3, 4]); // Promise that resolves to [1, 2, 3, 4]
 * AsyncAF(arr).concatAF([3, 4], [5, 6]); // Promise that resolves to [1, 2, 3, 4, 5, 6]
 *
 * // nested arrays
 * const arr1 = Promise.resolve([1, 2]);
 * const arr2 = [3, [4, 5]];
 * AsyncAF(arr1).concatAF(arr2); // Promise that resolves to [1, 2, 3, [4, 5]]
 *
 * // strings
 * const str = Promise.resolve('str');
 * AsyncAF(str).concatAF('ing'); // Promise that resolves to 'string'
 * AsyncAF(str).concatAF('ing', 'y'); // Promise that resolves to 'stringy'
 *
 * // other instances of AsyncAF
 * const aaf1 = AsyncAF([1, 2]);
 * const aaf2 = AsyncAF(3);
 *
 * aaf1.concatAF(aaf2); // Promise that resolves to [1, 2, 3];
 *
 * const aaf3 = AsyncAF('stringy');
 * const aaf4 = AsyncAF('AF');
 *
 * aaf3.concatAF(aaf4); // Promise that resolves to 'stringyAF'
 *
 * // promises
 * const [p1, p2, p3] = [[1, 2], 3, [4, [5, 6]]].map(v => Promise.resolve(v));
 *
 * AsyncAF(p1).concatAF(p2); // Promise that resolves to [1, 2, 3]
 * AsyncAF(p1).concatAF(p2, p3) // Promise that resolves to [1, 2, 3, 4, [5, 6]]
 *
 * const pStr1 = Promise.resolve('str');
 * const pStr2 = Promise.resolve('ing');
 * const pStr3 = Promise.resolve('y');
 *
 * AsyncAF(pStr1).concatAF(pStr2); // Promise that resolves to 'string'
 * AsyncAF(pStr1).concatAF(pStr2, pStr3); // Promise that resolves to 'stringy'
 *
 * // Note: concatAF will not resolve deeply nested promises; if you need this behavior, concatAF can be used in a
 * // function; for example, this function recursively flattens an array of promises
 *
 * const flattenAsync = arr => AsyncAF(arr).reduceAF(async (acc, val) => {
 *   return Array.isArray(await val)
 *     ? AsyncAF(acc).concatAF(flattenAsync(val))
 *     : AsyncAF(acc).concatAF(val), []);
 * };
 *
 * @since 5.3.0
 * @see concat (alias)
 * @memberof AsyncAF#
 */


var concatAF = function concatAF() {
  var _this = this;

  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
    values[_key] = arguments[_key];
  }

  var isThenable = function isThenable(value) {
    return [Promise, _this.constructor].some(function (thenable) {
      return value instanceof thenable;
    });
  };

  var concat = function concat(arrOrStr, value) {
    return isThenable(value) && value.then(resolveByType).then(function (value) {
      return arrOrStr.concat(value);
    }) || arrOrStr.concat(value);
  };

  return this.then(function (arrOrStr) {
    if (!(typeof arrOrStr === 'string' || Array.isArray(arrOrStr))) throw TypeError("concatAF cannot be called on ".concat(arrOrStr, ", only on an Array or String"));
    return resolveByType(arrOrStr).then(function (arrOrStr) {
      return values.reduce(function (arrOrStr, value) {
        return isThenable(arrOrStr) ? arrOrStr.then(function (arrOrStr) {
          return concat(arrOrStr, value);
        }) : concat(arrOrStr, value);
      }, arrOrStr);
    });
  });
};

/* harmony default export */ __webpack_exports__["default"] = (concatAF);

/***/ }),

/***/ "./lib/methods/arrays/everyAF.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_commonCallback__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./lib/methods/_internal/commonCallback.js");
/* harmony import */ var _internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./lib/methods/_internal/permissiveIsArrayLike.js");
/* harmony import */ var _internal_resolve__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./lib/methods/_internal/resolve.js");
 // eslint-disable-line no-unused-vars



/**
 * tests whether all elements in the array pass the test implemented by the provided callback function
 *
 * if any elements are a `Promise`, they will first be resolved in parallel and then tested
 *
 * *Note*: since `everyAF` is run in parallel, `callback` will be run on all elements even if one of the first few elements fails the test; if this behavior is not desireable, consider using `series.everyAF` or its alias, `io.everyAF`
 *
 * @param {callback} callback function that tests each element of the array
 *
 * `callback` accepts three arguments:
 * - `currentValue` value of the current element being processed in the array
 * - `index`*`(optional)`* index of `currentValue` in the array
 * - `array`*`(optional)`* the array that `everyAF` is being applied to
 * @param {Object=} thisArg value to use as `this` when executing `callback`
 * @returns {Promise.<Boolean>} `Promise` that resolves to `true` if the callback function returns a truthy value for every array element; otherwise, `false`
 * @example
 *
 * const promises = [1, 2, 3].map(n => Promise.resolve(n));
 *
 *
 * // basic usage
 * const allAreOdd = AsyncAF(promises).everyAF(n => n % 2);
 *
 * console.log(allAreOdd); // Promise that resolves to false
 *
 * AsyncAF.logAF(allAreOdd); // logs false
 *
 *
 * // using .then
 * AsyncAF(promises).everyAF(n => n % 2).then(allAreOdd => {
 *   console.log(allAreOdd); // logs false
 * });
 *
 *
 * // inside an async function
 * (async () => {
 *   const allAreNums = await AsyncAF(promises).everyAF(
 *     n => typeof n === 'number'
 *   );
 *   console.log(allAreNums); // logs true
 * })();
 * @since 3.2.0
 * @see every (alias)
 * @see {@link AsyncAF#series series.everyAF}
 * @memberof AsyncAF#
 */

var everyAF = function everyAF(callback) {
  var _this = this;

  var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  return this.then(function (arr) {
    if (!Object(_internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_1__["default"])(arr)) throw TypeError("everyAF cannot be called on ".concat(arr, ", only on an Array or array-like Object"));
    if (typeof callback !== 'function') throw TypeError("".concat(callback, " is not a function"));
    var length = arr.length >>> 0;
    return _this.inSeries ? !length && true || function seriesEveryAF(arr, i) {
      var hole = !(i in arr);
      return Promise.resolve(arr[i]).then(function (el) {
        arr[i] = el;
        return Promise.resolve(!hole && callback.call(thisArg, el, i, arr)).then(function (bool) {
          if (!bool && !hole) return false;
          if (i === length - 1) return true;
          return seriesEveryAF(arr, i + 1);
        });
      });
    }(Array.prototype.slice.call(arr), 0) : Object(_internal_resolve__WEBPACK_IMPORTED_MODULE_2__["parallel"])(arr, callback, thisArg).then(function (bools) {
      return bools.every(Boolean);
    });
  });
};

/* harmony default export */ __webpack_exports__["default"] = (everyAF);

/***/ }),

/***/ "./lib/methods/arrays/filterAF.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_commonCallback__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./lib/methods/_internal/commonCallback.js");
/* harmony import */ var _internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./lib/methods/_internal/permissiveIsArrayLike.js");
/* harmony import */ var _internal_resolve__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./lib/methods/_internal/resolve.js");
 // eslint-disable-line no-unused-vars



/**
 * creates a new `Array` with all elements that pass the test implemented by the provided callback function
 *
 * if any elements are a `Promise`, they will first be resolved in parallel and then tested
 *
 * *Note*: if you'd rather resolve and test elements in series, consider using `series.filterAF` or its alias, `io.filterAF`
 *
 * @param {callback} callback function that tests each element of the array; return `true` to keep the element, `false` to filter it out
 *
 * `callback` accepts three arguments:
 * - `currentValue` value of the current element being processed in the array
 * - `index`*`(optional)`* index of `currentValue` in the array
 * - `array`*`(optional)`* the array that `filterAF` is being applied to
 * @param {Object=} thisArg value to use as `this` when executing `callback`
 * @returns {Promise.<Array>} `Promise` that resolves to a new `Array` with the elements that pass the test; if no elements pass the test, the promise will resolve to an empty array
 * @example
 *
 * const promises = [1, 2, 3].map(n => Promise.resolve(n));
 *
 *
 * // basic usage
 * const odds = AsyncAF(promises).filterAF(n => n % 2);
 *
 * console.log(odds); // Promise that resolves to [1, 3]
 *
 * AsyncAF.logAF(odds); // logs [1, 3]
 *
 *
 * // using .then
 * AsyncAF(promises).filterAF(n => n % 2).then(odds => {
 *   console.log(odds); // logs [1, 3]
 * });
 *
 *
 * // inside an async function
 * (async () => {
 *   const odds = await AsyncAF(promises).filterAF(
 *     n => n % 2
 *   );
 *   console.log(odds); // logs [1, 3]
 * })();
 * @since 3.0.0
 * @see filter (alias)
 * @see {@link AsyncAF#series series.filterAF}
 * @memberof AsyncAF#
 */

var filterAF = function filterAF(callback) {
  var _this = this;

  var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  return this.then(function (arr) {
    if (!Object(_internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_1__["default"])(arr)) throw TypeError("filterAF cannot be called on ".concat(arr, ", only on an Array or array-like Object"));
    if (typeof callback !== 'function') throw TypeError("".concat(callback, " is not a function"));
    return (_this.inSeries ? _internal_resolve__WEBPACK_IMPORTED_MODULE_2__["serial"] : _internal_resolve__WEBPACK_IMPORTED_MODULE_2__["parallel"])(arr).then(function (arr) {
      return (_this.inSeries ? arr.reduce(function (bools, el, i, arr) {
        return bools.then(function (bools) {
          bools[i] = callback.call(thisArg, el, i, arr);
          return Promise.all(bools);
        });
      }, Promise.all([])) : Object(_internal_resolve__WEBPACK_IMPORTED_MODULE_2__["parallel"])(arr, callback, thisArg)).then(function (bools) {
        return arr.filter(function (_, i) {
          return bools[i];
        });
      });
    });
  });
};

/* harmony default export */ __webpack_exports__["default"] = (filterAF);

/***/ }),

/***/ "./lib/methods/arrays/findAF.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_commonCallback__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./lib/methods/_internal/commonCallback.js");
/* harmony import */ var _internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./lib/methods/_internal/permissiveIsArrayLike.js");
/* harmony import */ var _internal_resolve__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./lib/methods/_internal/resolve.js");
 // eslint-disable-line no-unused-vars



/**
 * resolves to the value of the first element in the array that satisfies the provided callback function; otherwise, `undefined`
 *
 * *Note*: since `findAF` is run in parallel, `callback` will be run on all elements even if one of the first few elements passes the test; if this behavior is not desireable, consider using `series.findAF` or its alias, `io.findAF`
 *
 * @param {callback} callback function to test each element in the array
 *
 * `callback` accepts three arguments:
 * - `currentValue` value of the current element being processed in the array
 * - `index`*`(optional)`* index of `currentValue` in the array
 * - `array`*`(optional)`* the array that findAF is being applied to
 * @param {Object=} thisArg value to use as `this` when executing `callback`
 * @returns {Promise.<any>} `Promise` that resolves to the first element in the array that passes the test; otherwise, undefined
 * @example
 *
 * const inventory = [
 *  {name: 'nuts', quantity: 2000},
 *  {name: 'bolts', quantity: 5000},
 *  {name: 'screws', quantity: 9001}
 * ].map(part => Promise.resolve(part));
 *
 * AsyncAF(inventory).findAF(part => part.name === 'screws');
 * // Promise that resolves to {name: 'screws', quantity: 9001}
 * @since 3.5.0
 * @see find (alias)
 * @see {@link AsyncAF#series series.findAF}
 * @memberof AsyncAF#
 */

var findAF = function findAF(callback) {
  var _this = this;

  var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  return this.then(function (arr) {
    if (!Object(_internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_1__["default"])(arr)) throw TypeError("findAF cannot be called on ".concat(arr, ", only on an Array or array-like Object"));
    if (typeof callback !== 'function') throw TypeError("".concat(callback, " is not a function"));
    var filled = Array.from(arr);
    var length = filled.length >>> 0;
    return _this.inSeries ? (length || undefined) && function seriesFindAF(arr, i) {
      return Promise.resolve(arr[i]).then(function (el) {
        arr[i] = el;
        return Promise.resolve(callback.call(thisArg, el, i, arr)).then(function (bool) {
          if (bool) return el;
          if (i === length - 1) return;
          return seriesFindAF(arr, i + 1);
        });
      });
    }(filled, 0) : Object(_internal_resolve__WEBPACK_IMPORTED_MODULE_2__["parallel"])(filled, callback, thisArg).then(function (bools) {
      return arr[bools.indexOf(true)];
    });
  });
};

/* harmony default export */ __webpack_exports__["default"] = (findAF);

/***/ }),

/***/ "./lib/methods/arrays/findIndexAF.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_commonCallback__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./lib/methods/_internal/commonCallback.js");
/* harmony import */ var _internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./lib/methods/_internal/permissiveIsArrayLike.js");
/* harmony import */ var _internal_resolve__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./lib/methods/_internal/resolve.js");
 // eslint-disable-line no-unused-vars



/**
 * resolves to the index of the first element in the array that satisfies the provided callback function; otherwise, `-1`
 *
 * *Note*: since `findIndexAF` is run in parallel, `callback` will be run on all indices even if one of the first few indices passes the test; if this behavior is not desireable, consider using `series.findIndexAF` or its alias, `io.findIndexAF`
 *
 * @param {callback} callback function to test each element in the array
 *
 * `callback` accepts three arguments:
 * - `currentValue` value of the current element being processed in the array
 * - `index`*`(optional)`* index of `currentValue` in the array
 * - `array`*`(optional)`* the array that findIndexAF is being applied to
 * @param {Object=} thisArg value to use as `this` when executing `callback`
 * @returns {Promise.<Number>} `Promise` that resolves to the index of the first element in the array that passes the test; otherwise, `-1`
 * @example
 *
 * const inventory = [
 *  {name: 'nuts', quantity: 2000},
 *  {name: 'bolts', quantity: 5000},
 *  {name: 'screws', quantity: 9001}
 * ].map(part => Promise.resolve(part));
 *
 * AsyncAF(inventory).findIndexAF(part => part.name === 'screws');
 * // Promise that resolves to 2
 * @since 3.5.0
 * @see findIndex (alias)
 * @see {@link AsyncAF#series series.findIndexAF}
 * @memberof AsyncAF#
 */

var findIndexAF = function findIndexAF(callback) {
  var _this = this;

  var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  return this.then(function (arr) {
    if (!Object(_internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_1__["default"])(arr)) throw TypeError("findIndexAF cannot be called on ".concat(arr, ", only on an Array or array-like Object"));
    if (typeof callback !== 'function') throw TypeError("".concat(callback, " is not a function"));
    var filled = Array.from(arr);
    var length = filled.length >>> 0;
    return _this.inSeries ? !length && -1 || function seriesFindIndexAF(arr, i) {
      return Promise.resolve(arr[i]).then(function (el) {
        arr[i] = el;
        return Promise.resolve(callback.call(thisArg, el, i, arr)).then(function (bool) {
          if (bool) return i;
          if (i === length - 1) return -1;
          return seriesFindIndexAF(arr, i + 1);
        });
      });
    }(filled, 0) : Object(_internal_resolve__WEBPACK_IMPORTED_MODULE_2__["parallel"])(filled, callback, thisArg).then(function (bools) {
      return bools.indexOf(true);
    });
  });
};

/* harmony default export */ __webpack_exports__["default"] = (findIndexAF);

/***/ }),

/***/ "./lib/methods/arrays/forEachAF.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_commonCallback__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./lib/methods/_internal/commonCallback.js");
/* harmony import */ var _internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./lib/methods/_internal/permissiveIsArrayLike.js");
/* harmony import */ var _internal_resolve__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./lib/methods/_internal/resolve.js");
 // eslint-disable-line no-unused-vars



/**
 * executes a callback function on each element in an array
 *
 * if any elements are a `Promise`, they will first be resolved in parallel and then processed
 *
 * *Note*: if you'd rather resolve and process elements in series, consider using `series.forEachAF` or its alias, `io.forEachAF`
 *
 * @param {callback} callback function to execute for each element
 *
 * `callback` accepts three arguments:
 * - `currentValue` value of the current element being processed in the array
 * - `index`*`(optional)`* index of `currentValue` in the array
 * - `array`*`(optional)`* the array that forEachAF is being applied to
 * @param {Object=} thisArg value to use as `this` when executing `callback`
 * @returns {Promise.<undefined>} `Promise` that resolves to `undefined`
 * @example
 *
 * const promises = [1, 2].map(n => Promise.resolve(n));
 *
 *
 * AsyncAF(promises).forEachAF(el => {
 *   console.log(el); // logs 1 then 2
 * });
 * @since 3.0.0
 * @see forEach (alias)
 * @see {@link AsyncAF#series series.forEachAF}
 * @memberof AsyncAF#
 */

var forEachAF = function forEachAF(callback) {
  var _this = this;

  var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  return this.then(function (arr) {
    if (!Object(_internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_1__["default"])(arr)) throw TypeError("forEachAF cannot be called on ".concat(arr, ", only on an Array or array-like Object"));
    if (typeof callback !== 'function') throw TypeError("".concat(callback, " is not a function"));
    return (_this.inSeries ? Object(_internal_resolve__WEBPACK_IMPORTED_MODULE_2__["serial"])(arr).then(function (arr) {
      return arr.reduce(function (expr, el, i, arr) {
        return expr.then(function () {
          return Promise.resolve(callback.call(thisArg, el, i, arr));
        });
      }, Promise.resolve());
    }) : Object(_internal_resolve__WEBPACK_IMPORTED_MODULE_2__["parallel"])(arr, callback, thisArg)).then(function () {});
  });
};

/* harmony default export */ __webpack_exports__["default"] = (forEachAF);

/***/ }),

/***/ "./lib/methods/arrays/includesAF.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./lib/methods/_internal/permissiveIsArrayLike.js");
/* harmony import */ var _internal_resolve__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./lib/methods/_internal/resolve.js");



var sameValueZero = function sameValueZero(a, b) {
  return a === b || Number.isNaN(a) && Number.isNaN(b);
};
/**
 * determines whether an array, string, or array-like object includes a certain element or string, returning true or false as appropriate
 *
 * *Note*: when called on an array or array-like object, `includesAF` is run in parallel and all elements will be resolved even if one of the first few elements is a match; if this behavior is not desireable, consider using `series.includesAF` or its alias, `io.includesAF`
 *
 * @param {any} searchItem the element or string to search for
 * @param {Number=} fromIndex the index at which to begin searching for `searchItem`; a negative value searches from the index of `array/string.length - fromIndex`; defaults to `0`
 * @returns {Promise.<Boolean>} `Promise` that resolves to `true` if `searchItem` is found; otherwise, `false`
 * @example
 *
 * // includesAF on an array of promises
 * const nums = [1, 2, 3].map(n => Promise.resolve(n));
 *
 * AsyncAF(nums).includesAF(2); // Promise that resolves to true
 *
 * AsyncAF(nums).includesAF(5); // Promise that resolves to false
 *
 * AsyncAF(nums).includesAF(1, 1); // Promise that resolves to false
 *
 * AsyncAF(nums).includesAF(3, -1); // Promise that resolves to true
 *
 * // includesAF on a promise-wrapped string
 * const string = Promise.resolve('test string');
 *
 * AsyncAF(string).includesAF('test'); // Promise that resolves to true
 *
 * AsyncAF(string).includesAF('nope'); // Promise that resolves to false
 *
 * AsyncAF(string).includesAF('test', 5); // Promise that resolves to false
 *
 * AsyncAF(string).includesAF('string', -6); // Promise that resolves to true
 *
 * // includesAF on an array-like object
 * (async function () {
 *   if (await AsyncAF(arguments).includesAF(2)) {
 *     console.log('2 is included');
 *   }
 * })(1, 2, 3); // logs '2 is included'
 *
 * @since 3.4.0
 * @see includes (alias)
 * @see {@link AsyncAF#series series.includesAF}
 * @memberof AsyncAF#
 */


var includesAF = function includesAF(searchItem) {
  var _this = this;

  var fromIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return this.then(function (arrOrStr) {
    if (!Object(_internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_0__["default"])(arrOrStr)) throw TypeError("includesAF cannot be called on ".concat(arrOrStr, ", only on an Array, String, or array-like Object"));
    var length = arrOrStr.length >>> 0;
    var fromIdx = fromIndex | 0;
    return typeof arrOrStr === 'string' ? arrOrStr.includes(searchItem, fromIdx) : _this.inSeries ? (length || false) && function seriesIncludesAF(i) {
      return Promise.resolve(arrOrStr[i]).then(function (el) {
        if (sameValueZero(el, searchItem)) return true;
        if (i >= length - 1) return false;
        return seriesIncludesAF(i + 1);
      });
    }(Math.max(fromIdx >= 0 ? fromIdx : length - Math.abs(fromIdx), 0)) : Object(_internal_resolve__WEBPACK_IMPORTED_MODULE_1__["parallel"])(arrOrStr).then(function (arr) {
      return arr.includes(searchItem, fromIdx);
    });
  });
};

/* harmony default export */ __webpack_exports__["default"] = (includesAF);

/***/ }),

/***/ "./lib/methods/arrays/indexOfAF.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./lib/methods/_internal/permissiveIsArrayLike.js");
/* harmony import */ var _internal_resolve__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./lib/methods/_internal/resolve.js");


/**
 * resolves to the first index of the specified element or string in an array, string, or array-like object, starting the search at `fromIndex`; if the value is not found, resolves to `-1`
 *
 * *Note*: when called on an array or array-like object, `indexOfAF` is run in parallel and all elements will be resolved even if one of the first few indices is a match; if this behavior is not desireable, consider using `series.indexOfAF` or its alias, `io.indexOfAF`
 *
 * @param {any} searchItem the element or string to search for
 * @param {Number=} fromIndex the index at which to begin searching for `searchItem`; a negative value searches from the index of `array/string.length - fromIndex`; defaults to `0`
 * @returns {Promise.<Number>} `Promise` that resolves to the index of `searchItem` if found; otherwise, `-1`
 * @example
 *
 * // indexOfAF on an array of promises
 * const nums = [1, 2, 3].map(n => Promise.resolve(n));
 *
 * AsyncAF(nums).indexOfAF(2); // Promise that resolves to 1
 *
 * AsyncAF(nums).indexOfAF(5); // Promise that resolves to -1
 *
 * AsyncAF(nums).indexOfAF(1, 1); // Promise that resolves to -1
 *
 * AsyncAF(nums).indexOfAF(3, -1); // Promise that resolves to 2
 *
 * // indexOfAF on a promise-wrapped string
 * const string = Promise.resolve('test string');
 *
 * AsyncAF(string).indexOfAF('test'); // Promise that resolves to 0
 *
 * AsyncAF(string).indexOfAF('nope'); // Promise that resolves to -1
 *
 * AsyncAF(string).indexOfAF('test', 5); // Promise that resolves to -1
 *
 * AsyncAF(string).indexOfAF('string', -6); // Promise that resolves to 5
 *
 * // indexOfAF on an array-like object
 * (async function () {
 *   if (await AsyncAF(arguments).indexOfAF(2) > -1) {
 *     console.log('2 is included');
 *   }
 * })(1, 2, 3); // logs '2 is included'
 *
 * @since 3.5.0
 * @see indexOf (alias)
 * @see {@link AsyncAF#series series.indexOfAF}
 * @memberof AsyncAF#
 */

var indexOfAF = function indexOfAF(searchItem) {
  var _this = this;

  var fromIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return this.then(function (arrOrStr) {
    if (!Object(_internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_0__["default"])(arrOrStr)) throw TypeError("indexOfAF cannot be called on ".concat(arrOrStr, ", only on an Array, String, or array-like Object"));
    var length = arrOrStr.length >>> 0;
    var fromIdx = fromIndex | 0;
    return typeof arrOrStr === 'string' ? arrOrStr.indexOf(searchItem, fromIdx) : _this.inSeries ? function seriesIndexOfAF(i) {
      return Promise.resolve(arrOrStr[i]).then(function (el) {
        if (i in arrOrStr && el === searchItem) return i;
        if (i >= length - 1) return -1;
        return seriesIndexOfAF(i + 1);
      });
    }(Math.max(fromIdx >= 0 ? fromIdx : length - Math.abs(fromIdx), 0)) : Object(_internal_resolve__WEBPACK_IMPORTED_MODULE_1__["parallel"])(arrOrStr).then(function (arr) {
      return arr.indexOf(searchItem, fromIdx);
    });
  });
};

/* harmony default export */ __webpack_exports__["default"] = (indexOfAF);

/***/ }),

/***/ "./lib/methods/arrays/joinAF.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./lib/methods/_internal/permissiveIsArrayLike.js");
/* harmony import */ var _internal_resolve__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./lib/methods/_internal/resolve.js");


/**
 * joins all elements of an array or array-like object into a string and resolves to that string
 *
 * @param {any} separator the string that separates each element in the resulting string; defaults to `','`; non-string separators will be converted to strings if necessary; if `separator` is an empty string `''`, the array elements are joined without any characters between them
 * @returns {Promise.<String>} `Promise` that resolves to a string with all array elements joined; if array.length is `0`, an empty string `''` is returned
 * @example
 *
 * const animals = ['cow', 'chicken', 'cat', 'dog'].map(a => Promise.resolve(a));
 *
 * // joinAF separator defaults to ','
 * AsyncAF(animals).joinAF(); // Promise that resolves to 'cow,chicken,cat,dog'
 *
 * // specifying separator
 * AsyncAF(animals).joinAF(' & '); // Promise that resolves to 'cow & chicken & cat & dog'
 *
 * // a non-string separator will be converted to a string
 * AsyncAF(animals).joinAF(2); // Promise that resolves to 'cow2chicken2cat2dog'
 *
 * // empty string separator
 * AsyncAF(animals).joinAF(''); // Promise that resolves to 'cowchickencatdog'
 *
 * // joining an empty array resolves to an empty string
 * AsyncAF([]).joinAF('+'); // Promise that resolves to ''
 *
 * // joinAF on an array-like object
 * (async function () {
 *  const list = await AsyncAF(arguments).joinAF(' - ');
 *  console.log(`Shopping List: ${list}`);
 * })('eggs', 'milk', 'butter', 'pancake mix');
 * // Shopping List: eggs - milk - butter - pancake mix
 *
 * @since 3.6.0
 * @see join (alias)
 * @memberof AsyncAF#
 */

var joinAF = function joinAF() {
  var separator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ',';
  return this.then(function (arr) {
    if (!Object(_internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_0__["default"])(arr)) throw TypeError("joinAF cannot be called on ".concat(arr, ", only on an Array or array-like Object"));
    return Object(_internal_resolve__WEBPACK_IMPORTED_MODULE_1__["parallel"])(arr).then(function (arr) {
      return arr.join(separator);
    });
  });
};

Object.defineProperty(joinAF, 'length', {
  value: 1
});
/* harmony default export */ __webpack_exports__["default"] = (joinAF);

/***/ }),

/***/ "./lib/methods/arrays/lastIndexOfAF.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./lib/methods/_internal/permissiveIsArrayLike.js");
/* harmony import */ var _internal_resolve__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./lib/methods/_internal/resolve.js");


/**
 * resolves to the last index of the specified element or string, searching backwards in an array, string, or array-like object; `fromIndex` offsets the start of the search; if the value is not found, resolves to `-1`
 *
 * *Note*: when called on an array or array-like object, `lastIndexOfAF` is run in parallel and all elements will be resolved even if one of the last few indices is a match; if this behavior is not desireable, consider using `series.lastIndexOfAF` or its alias, `io.lastIndexOfAF`
 *
 * @param {any} searchItem the element or string to search for
 * @param {Number=} fromIndex the index at which to begin searching backwards for `searchItem`; a negative value searches from the index of `array/string.length - fromIndex`; defaults to `array/string.length - 1`
 * @returns {Promise.<Number>} `Promise` that resolves to the last index of `searchItem` if found; otherwise, `-1`
 * @example
 *
 * // lastIndexOfAF on an array of promises
 * const nums = [1, 1, 2, 2, 3, 3].map(n => Promise.resolve(n));
 *
 * AsyncAF(nums).lastIndexOfAF(2); // Promise that resolves to 3
 *
 * AsyncAF(nums).lastIndexOfAF(5); // Promise that resolves to -1
 *
 * AsyncAF(nums).lastIndexOfAF(2, -4); // Promise that resolves to 2
 *
 * AsyncAF(nums).lastIndexOfAF(3, -3); // Promise that resolves to -1
 *
 * // lastIndexOfAF on a promise-wrapped string
 * const string = Promise.resolve('test string to test');
 *
 * AsyncAF(string).lastIndexOfAF('test'); // Promise that resolves to 15
 *
 * AsyncAF(string).lastIndexOfAF('nope'); // Promise that resolves to -1
 *
 * AsyncAF(string).lastIndexOfAF('test', -5); // Promise that resolves to 0
 *
 * AsyncAF(string).lastIndexOfAF('to', -7); // Promise that resolves to -1
 *
 * // lastIndexOfAF on an array-like object
 * (async function () {
 *   const lastIndexOf2 = await AsyncAF(arguments).lastIndexOfAF(2);
 *   console.log(`the last index of 2 in the arguments array-like object is ${lastIndexOf2}`)
 * })(1, 1, 2, 2, 3, 3); // the last index of 2 in the arguments array-like object is 3
 *
 * @since 3.6.0
 * @see lastIndexOf (alias)
 * @see {@link AsyncAF#series series.lastIndexOfAF}
 * @memberof AsyncAF#
 */

var lastIndexOfAF = function lastIndexOfAF(searchItem) {
  var _this = this;

  var fromIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  return this.then(function (arrOrStr) {
    if (!Object(_internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_0__["default"])(arrOrStr)) throw TypeError("lastIndexOfAF cannot be called on ".concat(arrOrStr, ", only on an Array, String, or array-like Object"));
    var len = arrOrStr.length >>> 0;
    var fromIdx = Number(fromIndex);
    if (Number.isNaN(fromIdx)) fromIdx = len - 1;
    return typeof arrOrStr === 'string' ? arrOrStr.lastIndexOf(searchItem, fromIdx) : _this.inSeries ? function seriesLastIndexOfAF(i) {
      return Promise.resolve(arrOrStr[i]).then(function (el) {
        if (i in arrOrStr && el === searchItem) return i;
        if (i <= 0) return -1;
        return seriesLastIndexOfAF(i - 1);
      });
    }(Math.min(fromIdx >= 0 ? fromIdx : Math.max(len - Math.abs(fromIdx), 0), len - 1)) : Object(_internal_resolve__WEBPACK_IMPORTED_MODULE_1__["parallel"])(arrOrStr).then(function (arr) {
      return arr.lastIndexOf(searchItem, fromIdx);
    });
  });
};

/* harmony default export */ __webpack_exports__["default"] = (lastIndexOfAF);

/***/ }),

/***/ "./lib/methods/arrays/mapAF.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_commonCallback__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./lib/methods/_internal/commonCallback.js");
/* harmony import */ var _internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./lib/methods/_internal/permissiveIsArrayLike.js");
/* harmony import */ var _internal_promiseAllWithHoles__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./lib/methods/_internal/promiseAllWithHoles.js");
/* harmony import */ var _internal_resolve__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./lib/methods/_internal/resolve.js");
 // eslint-disable-line no-unused-vars




/**
 * creates a new `Array` with the results of calling a provided function on every element in the original array
 *
 * if any elements are a `Promise`, they will first be resolved in parallel and then processed
 *
 * *Note*: if you'd rather resolve and process elements in series, consider using `series.mapAF` or its alias, `io.mapAF`
 *
 * @param {callback} callback function that produces an element of the new `Array`
 *
 * `callback` accepts three arguments:
 * - `currentValue` value of the current element being processed in the array
 * - `index`*`(optional)`* index of `currentValue` in the array
 * - `array`*`(optional)`* the array that mapAF is being applied to
 * @param {Object=} thisArg value to use as `this` when executing `callback`
 * @returns {Promise.<Array>} `Promise` that resolves to a new `Array` with each element being the result of calling `callback` on each original element
 * @example
 *
 * const promises = [1, 2].map(n => Promise.resolve(n));
 *
 *
 * // basic usage
 * const doubled = AsyncAF(promises).mapAF(el => el * 2);
 *
 * console.log(doubled); // Promise that resolves to [2, 4]
 *
 * AsyncAF.logAF(doubled); // logs [2, 4]
 *
 *
 * // using .then
 * AsyncAF(promises).mapAF(el => el * 3).then(tripled => {
 *   console.log(tripled); // logs [3, 6]
 * });
 *
 *
 * // inside an async function
 * (async () => {
 *   const quadrupled = await AsyncAF(promises).mapAF(
 *     el => el * 4
 *   );
 *   console.log(quadrupled); // logs [4, 8]
 * })();
 * @since 3.0.0
 * @see map (alias)
 * @see {@link AsyncAF#series series.mapAF}
 * @memberof AsyncAF#
 */

var mapAF = function mapAF(callback) {
  var _this = this;

  var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  return this.then(function (arr) {
    if (!Object(_internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_1__["default"])(arr)) throw TypeError("mapAF cannot be called on ".concat(arr, ", only on an Array or array-like Object"));
    if (typeof callback !== 'function') throw TypeError("".concat(callback, " is not a function"));
    return _this.inSeries ? Object(_internal_resolve__WEBPACK_IMPORTED_MODULE_3__["serial"])(arr).then(function (arr) {
      return arr.reduce(function (map, el, i, arr) {
        return map.then(function (map) {
          map[i] = Promise.resolve(callback.call(thisArg, el, i, arr));
          return Object(_internal_promiseAllWithHoles__WEBPACK_IMPORTED_MODULE_2__["default"])(map);
        });
      }, Promise.resolve(Array(arr.length >>> 0)));
    }) : Object(_internal_resolve__WEBPACK_IMPORTED_MODULE_3__["parallel"])(arr, callback, thisArg);
  });
};

/* harmony default export */ __webpack_exports__["default"] = (mapAF);

/***/ }),

/***/ "./lib/methods/arrays/reduceAF.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/slicedToArray.js
var slicedToArray = __webpack_require__("./node_modules/@babel/runtime/helpers/slicedToArray.js");
var slicedToArray_default = /*#__PURE__*/__webpack_require__.n(slicedToArray);

// CONCATENATED MODULE: ./lib/methods/_internal/reduceCallback.js
/* eslint-disable no-unused-vars, valid-jsdoc */

/**
 * @typedef {callback} _
 * @param {?} accumulator
 * @param {?} currentValue
 * @param {Number=} index
 * @param {[]=} array
 */
function reduceCallback_callback(accumulator, currentValue, index, array) {}

/* harmony default export */ var reduceCallback = (reduceCallback_callback);
// EXTERNAL MODULE: ./lib/methods/_internal/permissiveIsArrayLike.js
var permissiveIsArrayLike = __webpack_require__("./lib/methods/_internal/permissiveIsArrayLike.js");

// EXTERNAL MODULE: ./lib/methods/_internal/resolve.js
var resolve = __webpack_require__("./lib/methods/_internal/resolve.js");

// CONCATENATED MODULE: ./lib/methods/arrays/reduceAF.js

 // eslint-disable-line no-unused-vars



/* eslint-disable prefer-rest-params */

/**
 * applies a function against an accumulator and each element in an array (from left to right) to reduce it to a single value
 *
 * if any elements are a `Promise`, they will first be resolved in parallel and then processed in series
 *
 * *Note*: if this behavior is not desirable, consider using `series.reduceAF` or its alias, `io.reduceAF`; that way, if any elements are a `Promise`, they will both be resolved in series _and_ processed in series
 *
 * @param {callback} callback function to execute for each element
 *
 * `callback` accepts up to four arguments:
 * - `accumulator` accumulates the callback's return values; the accumulated value previously returned in the last invocation of the callback, or initialValue, if supplied
 * - `currentValue` value of the current element being processed in the array
 * - `index`*`(optional)`* index of `currentValue` in the array
 * - `array`*`(optional)`* the array that `reduceAF` is being applied to
 * @param {any=} initialValue value to use as the first argument to the first call of the callback; if no initial value is supplied, the first element in the array will be used; note: calling reduceAF on an empty array with no initial value will throw an error
 * @returns {Promise.<any>} `Promise` that resolves to the reduced value
 * @example
 *
 * const promises = [1, 2, 3].map(n => Promise.resolve(n));
 *
 *
 * // basic usage
 * const sum = AsyncAF(promises).reduceAF((sum, num) => sum + num);
 *
 * console.log(sum); // Promise that resolves to 6
 *
 * AsyncAF.logAF(sum); // logs 6
 *
 *
 * // using .then
 * AsyncAF(promises).reduceAF((sum, num) => sum + num).then(sum => {
 *   console.log(sum); // logs 6
 * });
 *
 *
 * // inside an async function
 * (async () => {
 *   const sum = await AsyncAF(promises).reduceAF((sum, num) => sum + num);
 *   console.log(sum); // logs 6
 * })();
 *
 *
 * // using an initial value
 * AsyncAF(promises).reduceAF((sum, num) => sum + num, 12) // Promise that resolves to 18
 * @since 3.1.0
 * @see reduce (alias)
 * @see {@link AsyncAF#series series.reduceAF}
 * @memberof AsyncAF#
 */

var reduceAF_reduceAF = function reduceAF(callback
/* , initialValue */
) {
  var _this = this,
      _arguments = arguments;

  return this.then(function (arr) {
    if (!Object(permissiveIsArrayLike["default"])(arr)) throw TypeError("reduceAF cannot be called on ".concat(arr, ", only on an Array or array-like Object"));
    if (typeof callback !== 'function') throw TypeError("".concat(callback, " is not a function"));
    var length = arr.length >>> 0;
    if (!length && _arguments.length === 1) throw TypeError('reduceAF cannot be called on an empty array without an initial value');
    if (!length) return _arguments[1];

    var hole = function hole(i) {
      return !(i in arr);
    };

    var i = 0;
    var acc;

    if (_arguments.length === 2) {
      var _arguments2 = slicedToArray_default()(_arguments, 2);

      acc = _arguments2[1];
    } else {
      while (hole(i)) {
        i++;
      }

      acc = arr[i++];
    }

    return (_this.inSeries ? resolve["serial"] : resolve["parallel"])(arr).then(function (arr) {
      var reduceAF = function reduceAF(acc, i) {
        return Promise.resolve(acc).then(function (acc) {
          return Promise.resolve(!hole(i) ? callback(acc, arr[i], i, arr) : acc).then(function (acc) {
            return i === length - 1 ? acc : reduceAF(acc, i + 1);
          });
        });
      };

      return reduceAF(acc, i);
    });
  });
};

/* harmony default export */ var arrays_reduceAF = __webpack_exports__["default"] = (reduceAF_reduceAF);

/***/ }),

/***/ "./lib/methods/arrays/someAF.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_commonCallback__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./lib/methods/_internal/commonCallback.js");
/* harmony import */ var _internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./lib/methods/_internal/permissiveIsArrayLike.js");
/* harmony import */ var _internal_resolve__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./lib/methods/_internal/resolve.js");
 // eslint-disable-line no-unused-vars



/**
 * tests whether at least one element in the array passes the test implemented by the provided callback function
 *
 * if any elements are a `Promise`, they will first be resolved in parallel and then tested
 *
 * *Note*: since `someAF` is run in parallel, `callback` will be run on all elements even if one of the first few elements passes the test; if this behavior is not desireable, consider using `series.someAF` or its alias, `io.someAF`
 *
 * @param {callback} callback function that tests each element of the array
 *
 * `callback` accepts three arguments:
 * - `currentValue` value of the current element being processed in the array
 * - `index`*`(optional)`* index of `currentValue` in the array
 * - `array`*`(optional)`* the array that `someAF` is being applied to
 * @param {Object=} thisArg value to use as `this` when executing `callback`
 * @returns {Promise.<Boolean>} `Promise` that resolves to `true` if the callback function returns a truthy value for any array element; otherwise, `false`
 * @example
 *
 * const promises = [1, 2, 3].map(n => Promise.resolve(n));
 *
 *
 * // basic usage
 * const someAreEven = AsyncAF(promises).someAF(n => n % 2 === 0);
 *
 * console.log(someAreEven); // Promise that resolves to true
 *
 * AsyncAF.logAF(someAreEven); // logs true
 *
 *
 * // using .then
 * AsyncAF(promises).someAF(n => n % 2 === 0).then(someAreEven => {
 *   console.log(someAreEven); // logs true
 * });
 *
 *
 * // inside an async function
 * (async () => {
 *   const someAreStrings = await AsyncAF(promises).someAF(
 *     n => typeof n === 'string'
 *   );
 *   console.log(someAreStrings); // logs false
 * })();
 * @since 3.3.0
 * @see some (alias)
 * @see {@link AsyncAF#series series.someAF}
 * @memberof AsyncAF#
 */

var someAF = function someAF(callback) {
  var _this = this;

  var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  return this.then(function (arr) {
    if (!Object(_internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_1__["default"])(arr)) throw TypeError("someAF cannot be called on ".concat(arr, ", only on an Array or array-like Object"));
    if (typeof callback !== 'function') throw TypeError("".concat(callback, " is not a function"));
    var length = arr.length >>> 0;
    return _this.inSeries ? (length || false) && function seriesSomeAF(arr, i) {
      var hole = !(i in arr);
      return Promise.resolve(arr[i]).then(function (el) {
        arr[i] = el;
        return Promise.resolve(!hole && callback.call(thisArg, el, i, arr)).then(function (bool) {
          if (bool && !hole) return true;
          if (i === length - 1) return false;
          return seriesSomeAF(arr, i + 1);
        });
      });
    }(Array.prototype.slice.call(arr), 0) : Object(_internal_resolve__WEBPACK_IMPORTED_MODULE_2__["parallel"])(arr, callback, thisArg).then(function (bools) {
      return bools.some(Boolean);
    });
  });
};

/* harmony default export */ __webpack_exports__["default"] = (someAF);

/***/ }),

/***/ "./lib/methods/other/logAF.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/toConsumableArray.js
var toConsumableArray = __webpack_require__("./node_modules/@babel/runtime/helpers/toConsumableArray.js");
var toConsumableArray_default = /*#__PURE__*/__webpack_require__.n(toConsumableArray);

// CONCATENATED MODULE: ./lib/methods/_internal/logging.js
/* eslint-disable no-console */
var wrappedLog = function wrappedLog() {
  var _console;

  console && console.log && (_console = console).log.apply(_console, arguments);
};

var wrappedWarn = function wrappedWarn() {
  var _console2;

  console && console.warn && (_console2 = console).warn.apply(_console2, arguments);
};


// CONCATENATED MODULE: ./lib/methods/other/logAfHelpers/logAfOptions.js

/**
 * Sets logging options for {@link AsyncAF#logAF logAF}
 *
 * accepts an options object with the following optional properties:
 * - label (`Boolean`) - set to `false` to disable logging the location of calls to logAF
 * - duration (`Boolean`) - set to `false` to disable logging the time it takes (in secs) to complete each call to logAF
 * - labelFormat (`String`|`Function`) - alters the format of logAF labels; choose between `file` (*default*), `path`, `parent`, `arrow`, or a custom string or function
 *
 * ```js
 * const promise = new Promise(resolve => setTimeout(
 *   () => resolve(1), 1000)
 * );
 * ```
 * **default logging**
 * ```js
 * logAF(promise, 2);
 *
 * // @filename.js:24:1:
 * // 1 2
 * // in 0.998 secs
 * ```
 * **turn off label**
 * ```js
 * logAF.options({ label: false });
 * logAF(promise, 2);
 *
 * // 1 2
 * // in 0.999 secs
 * ```
 * **turn off duration**
 * ```js
 * logAF.options({ duration: false });
 * logAF(promise, 2);
 *
 * // @filename.js:24:1:
 * // 1 2
 * ```
 * **change labelFormat**
 *
 * &#9679; file (*default*)
 *
 * ```js
 * logAF.options({ labelFormat: 'file' });
 * logAF(promise, 2);
 *
 * // @filename.js:24:1:
 * // 1 2
 * // in 0.998 secs
 * ```
 * &#9679; path
 *
 * ```js
 * logAF.options({ labelFormat: 'path' });
 * logAF(promise, 2);
 *
 * // @/Path/to/current/directory/filename.js:24:1:
 * // 1 2
 * // in 0.997 secs
 * ```
 * &#9679; parent
 *
 * ```js
 * logAF.options({ labelFormat: 'parent' });
 * logAF(promise, 2);
 *
 * // @parentDirectory/filename.js:24:1:
 * // 1 2
 * // in 0.998 secs
 * ```
 * &#9679; arrow
 *
 * ```js
 * logAF.options({ labelFormat: 'arrow' });
 * logAF(promise, 2);
 *
 * // ========================> 1 2
 * // in 0.999 secs
 * ```
 *
 * &#9679; custom (create your own labelFormat)
 *  - to set a custom labelFormat, set it to any string other than the formats above
 *
 * ```js
 * logAF.options({
 *  labelFormat: 'I logged this:'
 * });
 * logAF(promise, 2);
 *
 * // I logged this: 1 2
 * // in 1.000 secs
 * ```
 *
 * - labelFormat also accepts a function with access to an object containing the location variables `file`, `path`, `parent`, `arrow`, `line`, and `col`
 *
 * e.g., to set the labelFormat to `file:line:col =>`:
 * ```js
 * logAF.options({
 *  labelFormat: ({file, line, col}) => `${file}:${line}:${col} =>`
 * });
 * logAF(promise, 2);
 *
 * // filename.js:24:1 => 1 2
 * // in 0.998 secs
 * ```
 *
 * and just to demonstrate all the location variables in one custom format:
 * ```js
 * logAF.options({
 *   labelFormat: ({arrow, line, col, parent, file, path}) =>
 * `${arrow}
 * line: ${line}
 * col: ${col}
 * parent: ${parent}
 * file: ${file}
 * path: ${path}
 * `
 * });
 * logAF(promise, 2);
 *
 * // ========================>
 * // line: 24
 * // col: 1
 * // parent: parentDirectory/
 * // file: filename.js
 * // path: /Full/path/to/the/parentDirectory/
 * // 1 2
 * // in 0.998 secs
 * ```
 *
 * to reset `logAF.options` to its default values, call `logAF.options.reset`
 * ```js
 * logAF.options.reset();
 *
 * // options are now:
 * // label: true,
 * // duration: true,
 * // labelFormat: 'file'
 * ```
 *
 * @static
 * @param {Object} options the options for logAF
 * @param {Boolean} [options.label=true] set to false to turn off the label
 * @param {Boolean} [options.duration=true] set to false to turn off duration
 * @param {String|Function} [options.labelFormat=file] see examples for sample label formats
 * @returns {undefined} sets the options for logAF
 * @see {@link AsyncAF#logAF logAF}
 * @see logAF.options.reset to reset options to default
 * @memberof AsyncAF
 * @alias AsyncAF#logAF_options
 */

var logAfOptions_logAfOptions = function logAfOptions() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var label = options.label,
      duration = options.duration,
      labelFormat = options.labelFormat;
  if (typeof label === 'boolean') other_logAF.label = label;
  if (typeof duration === 'boolean') other_logAF.duration = duration;
  if (labelFormat) if (typeof labelFormat === 'string' || typeof labelFormat === 'function') other_logAF.labelFormat = labelFormat;else other_logAF.wrappedWarn('Warning: logAF labelFormat option must be set to \'file\' (default), \'path\', \'parent\', \'arrow\', or a custom string or function\n');
};

/* harmony default export */ var logAfHelpers_logAfOptions = (logAfOptions_logAfOptions);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js
var taggedTemplateLiteral = __webpack_require__("./node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js");
var taggedTemplateLiteral_default = /*#__PURE__*/__webpack_require__.n(taggedTemplateLiteral);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/slicedToArray.js
var slicedToArray = __webpack_require__("./node_modules/@babel/runtime/helpers/slicedToArray.js");
var slicedToArray_default = /*#__PURE__*/__webpack_require__.n(slicedToArray);

// CONCATENATED MODULE: ./lib/methods/other/logAfHelpers/customFormat.js



function _templateObject4() {
  var data = taggedTemplateLiteral_default()(["/"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = taggedTemplateLiteral_default()(["/"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = taggedTemplateLiteral_default()(["/"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = taggedTemplateLiteral_default()([":"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

var customFormat_custom = function custom(format, fullPath, arrow) {
  if (typeof format === 'string') return format;

  var _ref = fullPath.split(_templateObject()),
      _ref2 = slicedToArray_default()(_ref, 3),
      path = _ref2[0],
      line = _ref2[1],
      col = _ref2[2]; // eslint-disable-line prefer-const


  path = path.split(_templateObject2());
  var file = path.pop();
  path = path.join(_templateObject3());
  var parent = "".concat(path.split(_templateObject4()).pop(), "/");
  path += '/';
  return format({
    path: path,
    line: line,
    col: col,
    file: file,
    parent: parent,
    arrow: arrow
  });
};

/* harmony default export */ var customFormat = (customFormat_custom);
// CONCATENATED MODULE: ./lib/methods/other/logAfHelpers/setFormat.js



function setFormat_templateObject4() {
  var data = taggedTemplateLiteral_default()(["/"]);

  setFormat_templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function setFormat_templateObject3() {
  var data = taggedTemplateLiteral_default()(["/"]);

  setFormat_templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function setFormat_templateObject2() {
  var data = taggedTemplateLiteral_default()(["/"]);

  setFormat_templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function setFormat_templateObject() {
  var data = taggedTemplateLiteral_default()(["\n"], ["\\n"]);

  setFormat_templateObject = function _templateObject() {
    return data;
  };

  return data;
}



var setFormat_setFormat = function setFormat(labelFormat) {
  var error = new Error();
  /* istanbul ignore if */

  if (!error.stack) return '';

  var _filter = error.stack.split(setFormat_templateObject()).filter(function (_, i, lines) {
    return /logAF(?:\s+|\s+\[.+\]\s+)\(/.test(lines[i ? i - 1 : i]) || /logAfStub(?:\s+|\s+\[.+\]\s+)\(/.test(lines[i]);
  }),
      _filter2 = slicedToArray_default()(_filter, 1),
      targetLine = _filter2[0];

  var fullPath = targetLine.slice(targetLine.indexOf(setFormat_templateObject2())).replace(')', '');
  var target = fullPath.lastIndexOf(setFormat_templateObject3());
  var formats = {
    file: function file() {
      return "@".concat(fullPath.slice(target + 1), ":\n");
    },
    path: function path() {
      return "@".concat(fullPath, ":\n");
    },
    parent: function parent() {
      var start = fullPath.slice(0, target).lastIndexOf(setFormat_templateObject4()) + 1;
      return "@".concat(fullPath.slice(start), ":\n");
    },
    arrow: function arrow() {
      return '========================>';
    }
  };
  return formats[labelFormat] ? formats[labelFormat]() : customFormat(labelFormat, fullPath, formats.arrow());
};

/* harmony default export */ var logAfHelpers_setFormat = (setFormat_setFormat);
// EXTERNAL MODULE: ./lib/methods/_internal/nameFunction.js
var nameFunction = __webpack_require__("./lib/methods/_internal/nameFunction.js");

// CONCATENATED MODULE: ./lib/methods/other/logAF.js





/**
 * logs items to the console in the order given
 *
 * if any items are a promise, they will first be resolved in parallel and then logged
 *
 * ```js
 * import { logAF } from 'async-af';
 *
 * const promise = new Promise(resolve => setTimeout(
 *  () => resolve(2), 1000)
 * );
 *
 * logAF(1, promise, 3);
 *
 * // @filename.js:6:12:
 * // 1 2 3
 * // in 0.998 secs
 * ```
 *
 * **Note:** since logAF returns a promise, the items in the previous example would be logged *after* any synchronous calls to `console.log`
 *
 * to produce in-order logging with any surrounding calls to `console.log`, `await` logAF:
 * ```js
 * logAF.options({ label: false, duration: false });
 *
 * (async () => {
 *   console.log(1);
 *   // ...some code
 *   await logAF(promise);
 *   // ...some more code
 *   console.log(3);
 * })();
 *
 * // 1
 * // 2
 * // 3
 * ```
 *
 * **experimental feature**: the label may not work correctly in all environments; to turn the label off, set `label` to `false` in {@link AsyncAF#logAF_options logAF.options}, where you can also change the label's format
 *
 * @static
 * @param {any} items The items to print (log to the console)
 * @returns {Promise<undefined>} returns a `Promise` that logs items to the console
 * @see log (alias)
 * @see {@link AsyncAF#logAF_options logAF.options} to turn the label off or change its format
 * @see logAF.options.reset to reset options to default
 * @since 3.0.0
 * @memberof AsyncAF
 * @alias AsyncAF#logAF
 */

var logAF_logAF = function logAF() {
  for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {
    items[_key] = arguments[_key];
  }

  if (logAF.label) items.unshift(logAF.setFormat(logAF.labelFormat));
  var start = Date.now();
  return Promise.all(items).then(function (toLog) {
    if (logAF.duration) {
      var end = Date.now();
      var numberOf = ((end - start) / 1000).toFixed(3);
      toLog.push("\n in ".concat(numberOf, " secs"));
    }

    logAF.wrappedLog.apply(logAF, [''].concat(toConsumableArray_default()(toLog)));
  });
};

Object.defineProperties(logAF_logAF, {
  wrappedLog: {
    value: wrappedLog,
    writable: true
  },
  wrappedWarn: {
    value: wrappedWarn,
    writable: true
  },
  setFormat: {
    value: logAfHelpers_setFormat,
    writable: true
  },
  options: {
    value: logAfHelpers_logAfOptions,
    writable: true
  }
});
(logAF_logAF.options.reset = function logAfOptionsReset() {
  logAF_logAF.label = true;
  logAF_logAF.labelFormat = 'file';
  logAF_logAF.duration = true;
})();
/* harmony default export */ var other_logAF = __webpack_exports__["default"] = (Object(nameFunction["default"])(logAF_logAF, 'logAF'));

/***/ }),

/***/ "./lib/methods/strings/splitAF.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * splits a string into an array of substrings, using a specified separator to determine where to make each split
 *
 * @param {String|RegExp=} separator a string or regular expression that denotes the points at which each split should occur
 * - if a plain-text separator contains more than one character, the entire separator must be found to represent a split point
 * - if separator is omitted or does not occur in the string, the array returned will contain one element consisting of the entire string
 * - if separator is an empty string, the string is converted to an array of individual characters
 * - if separator is a regular expression, the array returned will also contain any separators found as a result of matches within capturing parentheses
 * @param {Number=} limit integer specifying a limit on the number of elements to be included in the result; when provided, the string is split at each occurrence of the specified separator but stops including elements when the limit is reached (or the end of the string, if reached sooner); any left-over text is not included in the result
 * @returns {Promise.<String[]>} `Promise` that resolves to an array of strings, split at each point the separator occurs in the given string
 * @example
 *
 * // basic usage
 * const str = Promise.resolve('s; p; l; i; t');
 *
 * AsyncAF(str).splitAF('; '); // Promise that resolves to ['s', 'p', 'l', 'i', 't']
 *
 * // no separator specified or separator not found
 * const str = Promise.resolve('splat');
 *
 * AsyncAF(str).splitAF(); // Promise that resolves to ['splat']
 * AsyncAF(str).splitAF('n/a'); // Promise that resolves to ['splat']
 *
 * // split to individual characters
 * const str = Promise.resolve('splitAF');
 *
 * AsyncAF(str).splitAF(''); // Promise that resolves to ['s', 'p', 'l', 'i', 't', 'A', 'F']
 *
 * // split on a regular expression
 * const str = Promise.resolve('splittedAF');
 *
 * AsyncAF(str).splitAF(/sp|ted/); // Promise that resolves to ['', 'lit', 'AF']
 *
 * // and w/ capturing parentheses
 *
 * AsyncAF(str).splitAF(/(lit|AF)/); // Promise that resolves to ['sp', 'lit', '', 'AF', '']
 *
 * // setting limit
 * const str = Promise.resolve('splitted');
 *
 * AsyncAF(str).splitAF('', 5); // Promise that resolves to ['s', 'p', 'l', 'i', 't']
 * AsyncAF(str).splitAF('', 12); // Promise that resolves to ['s', 'p', 'l', 'i', 't', 't', 'e', 'd']
 * AsyncAF(str).splitAF('', 0); // Promise that resolves to []
 *
 * @since 5.1.0
 * @see split (alias)
 * @memberof AsyncAF#
 */
var splitAF = function splitAF() {
  var separator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
  var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  return this.then(function (str) {
    if (typeof str !== 'string' || Array.isArray(str)) throw TypeError("splitAF may be called on a string but was called on ".concat(str));
    return String.prototype.split.call(str, separator, limit);
  });
};

/* harmony default export */ __webpack_exports__["default"] = (splitAF);

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js":
/***/ (function(module, exports) {

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js":
/***/ (function(module, exports) {

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

module.exports = _arrayWithoutHoles;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js":
/***/ (function(module, exports) {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/classCallCheck.js":
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/construct.js":
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__("./node_modules/@babel/runtime/helpers/setPrototypeOf.js");

function isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    module.exports = _construct = Reflect.construct;
  } else {
    module.exports = _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

module.exports = _construct;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/createClass.js":
/***/ (function(module, exports) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/defineProperty.js":
/***/ (function(module, exports) {

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js":
/***/ (function(module, exports) {

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/inherits.js":
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__("./node_modules/@babel/runtime/helpers/setPrototypeOf.js");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArray.js":
/***/ (function(module, exports) {

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

module.exports = _iterableToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js":
/***/ (function(module, exports) {

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableRest.js":
/***/ (function(module, exports) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

module.exports = _nonIterableRest;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableSpread.js":
/***/ (function(module, exports) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

module.exports = _nonIterableSpread;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/objectSpread.js":
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__("./node_modules/@babel/runtime/helpers/defineProperty.js");

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      defineProperty(target, key, source[key]);
    });
  }

  return target;
}

module.exports = _objectSpread;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js":
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__("./node_modules/@babel/runtime/helpers/typeof.js");

var assertThisInitialized = __webpack_require__("./node_modules/@babel/runtime/helpers/assertThisInitialized.js");

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js":
/***/ (function(module, exports) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/slicedToArray.js":
/***/ (function(module, exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__("./node_modules/@babel/runtime/helpers/arrayWithHoles.js");

var iterableToArrayLimit = __webpack_require__("./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js");

var nonIterableRest = __webpack_require__("./node_modules/@babel/runtime/helpers/nonIterableRest.js");

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js":
/***/ (function(module, exports) {

function _taggedTemplateLiteral(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }

  return Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
}

module.exports = _taggedTemplateLiteral;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/toConsumableArray.js":
/***/ (function(module, exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__("./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js");

var iterableToArray = __webpack_require__("./node_modules/@babel/runtime/helpers/iterableToArray.js");

var nonIterableSpread = __webpack_require__("./node_modules/@babel/runtime/helpers/nonIterableSpread.js");

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/***/ (function(module, exports) {

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ })

/******/ })["default"];
});
//# sourceMappingURL=index.js.map