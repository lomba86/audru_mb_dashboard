{"version":3,"file":"min.js","sources":["../../../lib/methods/_internal/nameFunction.js","../../../lib/methods/_internal/createNewlessClass.js","../../../lib/methods/other/series.js","../../../lib/classes/AsyncAfWrapper.js","../../../lib/methods/other/use.js","../../../lib/methods/other/logAfHelpers/setFormat.js","../../../lib/methods/other/logAF.js","../../../lib/methods/_internal/logging.js","../../../lib/methods/other/logAfHelpers/customFormat.js","../../../lib/methods/other/logAfHelpers/logAfOptions.js","../../../lib/methods/_internal/permissiveIsArrayLike.js","../../../lib/methods/_internal/promiseAllWithHoles.js","../../../lib/methods/_internal/resolve.js","../../../lib/methods/arrays/joinAF.js","../../../lib/methods/arrays/concatAF.js","../../../packageList.js","../../../lib/methods/arrays/mapAF.js","../../../lib/methods/arrays/forEachAF.js","../../../lib/methods/arrays/filterAF.js","../../../lib/methods/arrays/reduceAF.js","../../../lib/methods/arrays/everyAF.js","../../../lib/methods/arrays/someAF.js","../../../lib/methods/arrays/includesAF.js","../../../lib/methods/arrays/findAF.js","../../../lib/methods/arrays/findIndexAF.js","../../../lib/methods/arrays/indexOfAF.js","../../../lib/methods/arrays/lastIndexOfAF.js","../../../lib/methods/strings/splitAF.js","../../../lib/classes/AsyncAF.js"],"sourcesContent":["const nameFunction = function (fn, name) {\n  return Object.defineProperty(fn, 'name', {value: name, configurable: true});\n};\n\nexport default nameFunction;\n","import nameFn from './nameFunction';\n\nconst createNewlessClass = Class => {\n  const {name} = Class;\n  const Newless = function (...args) {\n    return new Class(...args);\n  };\n  Newless.prototype = Class.prototype;\n  Object.setPrototypeOf(Newless, Class);\n  Newless.prototype.constructor = Newless;\n  return nameFn(Newless, name);\n};\n\nexport default createNewlessClass;\n","const inSeries = new WeakMap();\n\nconst series = {\n  inSeries: {\n    get() {\n      return inSeries.get(this);\n    },\n  },\n  /**\n   * indicates that the next method invoked should be performed in series\n   *\n   * when you need to perform a method in series rather than in parallel, prepend the method with `series`; e.g.:\n   * ```js\n   * AsyncAF(promises).series.forEachAF(callback)\n   * ```\n   *\n   * `series` can currently be chained with:\n   * - {@link AsyncAF#everyAF everyAF}\n   * - {@link AsyncAF#filterAF filterAF}\n   * - {@link AsyncAF#findAF findAF}\n   * - {@link AsyncAF#findIndexAF findIndexAF}\n   * - {@link AsyncAF#forEachAF forEachAF}\n   * - {@link AsyncAF#includesAF includesAF}\n   * - {@link AsyncAF#indexOfAF indexOfAF}\n   * - {@link AsyncAF#lastIndexOfAF lastIndexOfAF}\n   * - {@link AsyncAF#mapAF mapAF}\n   * - {@link AsyncAF#reduceAF reduceAF}\n   * - {@link AsyncAF#someAF someAF}\n   *\n   * @example\n   * import delay from 'delay'; // {@link https://www.npmjs.com/package/delay}\n   *\n   * const nums = [2, 1];\n   *\n   * // perform a serial forEach by chaining {@link AsyncAF#series series} and {@link AsyncAF#forEachAF forEachAF}\n   * (async () => {\n   *   const start = Date.now();\n   *\n   *   await AsyncAF(nums).series.forEachAF(async num => {\n   *     await delay(num * 1000);\n   *     console.log(num, `at ~${Date.now() - start} ms`);\n   *   });\n   *\n   *   console.log(`total: ~${Date.now() - start} ms`);\n   * })();\n   *\n   * // logs:\n   * // 2  'at ~2000 ms'\n   * // 1  'at ~3000 ms'\n   * // total: ~3000 ms\n   *\n   *\n   * // perform a parallel forEach by omitting {@link AsyncAF#series series}\n   * (async () => {\n   *   const start = Date.now();\n   *\n   *   await AsyncAF(nums).forEachAF(async num => {\n   *     await delay(num * 1000);\n   *     console.log(num, `at ~${Date.now() - start} ms`);\n   *   });\n   *\n   *   console.log(`total: ~${Date.now() - start} ms`);\n   * })();\n   *\n   * // logs:\n   * // 1  'at ~1000 ms'\n   * // 2  'at ~2000 ms'\n   * // total: ~2000 ms\n   *\n   * @function series\n   * @returns {AsyncAF.<any>} returns an instance of AsyncAF that will perform the next method invocation serially\n   * @since 7.0.0\n   * @see {@link AsyncAF#io io} (alias)\n   * @memberof AsyncAF#\n   */\n  series: {\n    get() {\n      inSeries.set(this, !this.inSeries);\n      return this;\n    },\n  },\n  /**\n   * `io` (in order) indicates that the next method invoked should be performed in series\n   *\n   * when you need to perform a method in series rather than in parallel, prepend the method with `io`; e.g.:\n   * ```js\n   * AsyncAF(promises).io.forEachAF(callback)\n   * ```\n   *\n   * `io` is an alias for `series`; see {@link AsyncAF#series series's documentation} for more\n   * @function io\n   * @returns {AsyncAF.<any>} returns an instance of AsyncAF that will perform the next method invocation serially\n   * @since 7.0.0\n   * @see {@link AsyncAF#series series} (alias)\n   * @memberof AsyncAF#\n   */\n  io: {\n    get() {\n      return this.series;\n    },\n  },\n};\n\nexport default series;\n","import createNewlessClass from '../methods/_internal/createNewlessClass';\nimport use from '../methods/other/use';\nimport series from '../methods/other/series';\n\nconst dataStore = new WeakMap();\n\nclass AsyncAfWrapperProto {\n  constructor(data) {\n    dataStore.set(this, Promise.resolve(data));\n  }\n  then(resolve, reject) {\n    return this.constructor(dataStore.get(this).then(resolve, reject));\n  }\n  catch(reject) {\n    return this.then(null, reject);\n  }\n  finally(onFinally) {\n    return dataStore.get(this).finally(onFinally);\n  }\n}\n\nAsyncAfWrapperProto.use = use;\n\nObject.defineProperties(AsyncAfWrapperProto.prototype, {\n  ...series,\n  [Symbol.toStringTag]: {value: 'AsyncAF'},\n});\n\n/**\n * empty AsyncAF class wrapper\n *\n * AsyncAfWrapper is one option for cherry-picking only the methods you'd like to use in your code; {@link AsyncAfWrapper#use use}, {@link AsyncAF#series series}, and {@link AsyncAF#io io} are the only methods initially available on AsyncAfWrapper; see example below\n *\n * **Note:** while AsyncAfWrapper is a class, it can create instances with or without the `new` keyword\n *\n * **Example**\n *\n * say you only want to use {@link AsyncAF#mapAF mapAF}, {@link AsyncAF#filterAF filterAF}, {@link AsyncAF#forEachAF forEachAF}, and {@link AsyncAF#logAF logAF} instead of pulling in the entire AsyncAF library\n *\n * first, install the separate packages (e.g., for npm):\n *\n * `$ npm install --save @async-af/{wrapper,map,filter,foreach,log}`\n *\n * or, if on Windows:\n *\n * `$ npm install --save @async-af/wrapper @async-af/map @async-af/filter @async-af/foreach @async-af/log`\n *\n * then import the packages\n * ```js\n * import AsyncAF from '@async-af/wrapper'; // aliasing 'AsyncAfWrapper' as 'AsyncAF'\n * import mapAF from '@async-af/map';\n * import filterAF from '@async-af/filter';\n * import forEachAF from '@async-af/foreach';\n * import logAF from '@async-af/log';\n * ```\n *\n * _if you'd like to save some vertical screen real estate and cut the imports down to one line, see_ {@tutorial TOO_MANY_IMPORTS}\n *\n * then call {@link AsyncAfWrapper#use use}, including all prototype methods you'd like to add to AsyncAfWrapper's prototype in the first argument, `prototypeMethods` and all static methods you'd like to add to AsyncAfWrapper in the second optional argument, `staticMethods`\n * ```js\n * AsyncAF.use({ // prototype methods go in the first argument\n *   mapAF,\n *   filterAF,\n *   forEachAF\n * }, { // static methods go in the second argument\n *   logAF\n * });\n * ```\n *\n * ready to go!\n * ```js\n * const promises = [1, 2, 3].map(n => Promise.resolve(n));\n *\n * AsyncAF(promises).mapAF(n => n * 2).filterAF(n => n !== 4).forEachAF(n => console.log(n));\n * // logs 2 then 6\n *\n * AsyncAF.logAF(promises);\n * // @filename.js:24:9:\n * //  [ 1, 2, 3 ]\n * // in 0.003 secs\n * ```\n *\n * **protip:** you can use the same technique to add your own custom prototype or static methods to AsyncAfWrapper or even to the main AsyncAF class; see {@link AsyncAfWrapper#use use} for an example\n * @param {any} data the data to be wrapped by the AsyncAF class; can be promises or non-promises\n * @returns {Object} returns an instance of AsyncAfWrapper wrapping the passed in data\n * @since 3.0.0\n * @see AsyncAF\n * @see {@link AsyncAfWrapper#use use}\n * @see {@tutorial TOO_MANY_IMPORTS}\n * @class AsyncAfWrapper\n */\nconst AsyncAfWrapper = createNewlessClass(\n  class AsyncAfWrapper extends AsyncAfWrapperProto {},\n);\n\nexport {AsyncAfWrapperProto};\nexport default AsyncAfWrapper;\n","/**\n * adds prototype/static methods to AsyncAF or AsyncAfWrapper\n *\n * see {@link AsyncAfWrapper AsyncAfWrapper} for an example of how to cherry-pick AsyncAF methods you'd like to use rather than pulling in the entire AsyncAF library;\n *\n * for something different, the following shows how to add custom methods to AsyncAF & AsyncAfWrapper\n *\n * **Example**\n *\n * say you want to extend AsyncAF with your own prototype method that acts on an array of numbers or promises that resolve to numbers and naively adds them up\n *\n * let's call it sumAF; here's some code:\n *\n * ```js\n * // sumAF.js\n *\n * const sumAF = function () {\n *   return this.then(nums => Promise.all(nums))\n *     .then(nums => nums.reduce((sum, num) => sum + num));\n * };\n *\n * export default sumAF;\n * ```\n *\n * pull in {@link AsyncAF AsyncAF} or {@link AsyncAfWrapper AsyncAfWrapper} and `sumAF` to the file you'd like to use it in:\n *\n * ```js\n * // otherFile.js\n *\n * import AsyncAF from 'async-af'; // or import AsyncAF from '@async-af/wrapper';\n * import sumAF from './sumAF';\n * ```\n *\n * then, call `use` on `AsyncAF` and pass in `sumAF` wrapped in an object to the first parameter, `prototypeMethods`:\n *\n * ```js\n * // otherFile.js\n * // ...\n *\n * AsyncAF.use({sumAF});\n * ```\n *\n * ready! now your custom prototype method will be available on AsyncAF\n *\n * ```js\n * // otherFile.js\n * // ...\n *\n * const promises = [1, 2, 3].map(n => Promise.resolve(n));\n *\n * const sum = AsyncAF(promises).sumAF()\n *\n * AsyncAF.logAF(sum);\n * // @otherFile.js:10:9:\n * //  6\n * // in 0.001 secs\n * ```\n *\n * if you'd like to add a static method to AsyncAF, `use` accepts a second optional argument `staticMethods`; for example:\n *\n * ```js\n * const staticNoop = () => {};\n *\n * AsyncAF.use({}, {staticNoop});\n *\n * AsyncAF.staticNoop(); // noop\n * ```\n *\n * @static\n * @param {Object} prototypeMethods an Object containing the prototype methods you'd like to use\n * @param {Object=} staticMethods an Object containing the static methods you'd like to use\n * @returns {undefined} adds prototype/static methods to AsyncAF or AsyncAfWrapper\n * @since 3.0.0\n * @see AsyncAF\n * @see AsyncAfWrapper\n * @see {@tutorial TOO_MANY_IMPORTS}\n * @memberof AsyncAfWrapper\n * @alias AsyncAfWrapper#use\n */\nconst use = function use(prototypeMethods, staticMethods = {}) {\n  if (typeof prototypeMethods !== 'object') throw TypeError(\n    'prototypeMethods param accepts an Object containing the prototypeMethods you\\'d like to add to the AsyncAF prototype, or an empty Object',\n  );\n  if (typeof staticMethods !== 'object') throw TypeError(\n    'staticMethods param accepts an Object containing the staticMethods you\\'d like to add to AsyncAF',\n  );\n  Object.assign(this.prototype, prototypeMethods);\n  Object.assign(this, staticMethods);\n};\n\nexport default use;\n","import custom from './customFormat';\n\nconst setFormat = labelFormat => {\n  const error = new Error();\n  /* istanbul ignore if */\n  if (!error.stack) return '';\n  const [targetLine] = error.stack.split`\\n`.filter(\n    (_, i, lines) => (\n      /logAF(?:\\s+|\\s+\\[.+\\]\\s+)\\(/.test(lines[i ? i - 1 : i]) ||\n      /logAfStub(?:\\s+|\\s+\\[.+\\]\\s+)\\(/.test(lines[i])\n    ),\n  );\n  const fullPath = targetLine.slice(targetLine.indexOf`/`).replace(')', '');\n  const target = fullPath.lastIndexOf`/`;\n  const formats = {\n    file() {\n      return `@${fullPath.slice(target + 1)}:\\n`;\n    },\n    path() {\n      return `@${fullPath}:\\n`;\n    },\n    parent() {\n      const start = fullPath.slice(0, target).lastIndexOf`/` + 1;\n      return `@${fullPath.slice(start)}:\\n`;\n    },\n    arrow() {\n      return '========================>';\n    },\n  };\n  return formats[labelFormat]\n    ? formats[labelFormat]()\n    : custom(labelFormat, fullPath, formats.arrow());\n};\n\nexport default setFormat;\n","import {wrappedLog, wrappedWarn} from '../_internal/logging';\nimport options from './logAfHelpers/logAfOptions';\nimport setFormat from './logAfHelpers/setFormat';\nimport name from '../_internal/nameFunction';\n\n/**\n * logs items to the console in the order given\n *\n * if any items are a promise, they will first be resolved in parallel and then logged\n *\n * ```js\n * import { logAF } from 'async-af';\n *\n * const promise = new Promise(resolve => setTimeout(\n *  () => resolve(2), 1000)\n * );\n *\n * logAF(1, promise, 3);\n *\n * // @filename.js:6:12:\n * // 1 2 3\n * // in 0.998 secs\n * ```\n *\n * **Note:** since logAF returns a promise, the items in the previous example would be logged *after* any synchronous calls to `console.log`\n *\n * to produce in-order logging with any surrounding calls to `console.log`, `await` logAF:\n * ```js\n * logAF.options({ label: false, duration: false });\n *\n * (async () => {\n *   console.log(1);\n *   // ...some code\n *   await logAF(promise);\n *   // ...some more code\n *   console.log(3);\n * })();\n *\n * // 1\n * // 2\n * // 3\n * ```\n *\n * **experimental feature**: the label may not work correctly in all environments; to turn the label off, set `label` to `false` in {@link AsyncAF#logAF_options logAF.options}, where you can also change the label's format\n *\n * @static\n * @param {any} items The items to print (log to the console)\n * @returns {Promise<undefined>} returns a `Promise` that logs items to the console\n * @see log (alias)\n * @see {@link AsyncAF#logAF_options logAF.options} to turn the label off or change its format\n * @see logAF.options.reset to reset options to default\n * @since 3.0.0\n * @memberof AsyncAF\n * @alias AsyncAF#logAF\n */\nconst logAF = function (...items) {\n  if (logAF.label) items.unshift(logAF.setFormat(logAF.labelFormat));\n  const start = Date.now();\n  return Promise.all(items).then(toLog => {\n    if (logAF.duration) {\n      const end = Date.now();\n      const numberOf = ((end - start) / 1000).toFixed(3);\n      toLog.push(`\\n in ${numberOf} secs`);\n    }\n    logAF.wrappedLog('', ...toLog);\n  });\n};\n\nObject.defineProperties(logAF, {\n  wrappedLog: {value: wrappedLog, writable: true},\n  wrappedWarn: {value: wrappedWarn, writable: true},\n  setFormat: {value: setFormat, writable: true},\n  options: {value: options, writable: true},\n});\n\n(logAF.options.reset = function logAfOptionsReset() {\n  logAF.label = true;\n  logAF.labelFormat = 'file';\n  logAF.duration = true;\n})();\n\nexport default name(logAF, 'logAF');\n","/* eslint-disable no-console */\nconst wrappedLog = (...args) => {\n  console && console.log && console.log(...args);\n};\n\nconst wrappedWarn = (...args) => {\n  console && console.warn && console.warn(...args);\n};\n\nexport {wrappedLog, wrappedWarn};\n","const custom = (format, fullPath, arrow) => {\n  if (typeof format === 'string') return format;\n  let [path, line, col] = fullPath.split`:`; // eslint-disable-line prefer-const\n  path = path.split`/`;\n  const file = path.pop();\n  path = path.join`/`;\n  const parent = `${path.split`/`.pop()}/`;\n  path += '/';\n  return format({\n    path,\n    line,\n    col,\n    file,\n    parent,\n    arrow,\n  });\n};\n\nexport default custom;\n","import logAF from '../logAF';\n\n/**\n * Sets logging options for {@link AsyncAF#logAF logAF}\n *\n * accepts an options object with the following optional properties:\n * - label (`Boolean`) - set to `false` to disable logging the location of calls to logAF\n * - duration (`Boolean`) - set to `false` to disable logging the time it takes (in secs) to complete each call to logAF\n * - labelFormat (`String`|`Function`) - alters the format of logAF labels; choose between `file` (*default*), `path`, `parent`, `arrow`, or a custom string or function\n *\n * ```js\n * const promise = new Promise(resolve => setTimeout(\n *   () => resolve(1), 1000)\n * );\n * ```\n * **default logging**\n * ```js\n * logAF(promise, 2);\n *\n * // @filename.js:24:1:\n * // 1 2\n * // in 0.998 secs\n * ```\n * **turn off label**\n * ```js\n * logAF.options({ label: false });\n * logAF(promise, 2);\n *\n * // 1 2\n * // in 0.999 secs\n * ```\n * **turn off duration**\n * ```js\n * logAF.options({ duration: false });\n * logAF(promise, 2);\n *\n * // @filename.js:24:1:\n * // 1 2\n * ```\n * **change labelFormat**\n *\n * &#9679; file (*default*)\n *\n * ```js\n * logAF.options({ labelFormat: 'file' });\n * logAF(promise, 2);\n *\n * // @filename.js:24:1:\n * // 1 2\n * // in 0.998 secs\n * ```\n * &#9679; path\n *\n * ```js\n * logAF.options({ labelFormat: 'path' });\n * logAF(promise, 2);\n *\n * // @/Path/to/current/directory/filename.js:24:1:\n * // 1 2\n * // in 0.997 secs\n * ```\n * &#9679; parent\n *\n * ```js\n * logAF.options({ labelFormat: 'parent' });\n * logAF(promise, 2);\n *\n * // @parentDirectory/filename.js:24:1:\n * // 1 2\n * // in 0.998 secs\n * ```\n * &#9679; arrow\n *\n * ```js\n * logAF.options({ labelFormat: 'arrow' });\n * logAF(promise, 2);\n *\n * // ========================> 1 2\n * // in 0.999 secs\n * ```\n *\n * &#9679; custom (create your own labelFormat)\n *  - to set a custom labelFormat, set it to any string other than the formats above\n *\n * ```js\n * logAF.options({\n *  labelFormat: 'I logged this:'\n * });\n * logAF(promise, 2);\n *\n * // I logged this: 1 2\n * // in 1.000 secs\n * ```\n *\n * - labelFormat also accepts a function with access to an object containing the location variables `file`, `path`, `parent`, `arrow`, `line`, and `col`\n *\n * e.g., to set the labelFormat to `file:line:col =>`:\n * ```js\n * logAF.options({\n *  labelFormat: ({file, line, col}) => `${file}:${line}:${col} =>`\n * });\n * logAF(promise, 2);\n *\n * // filename.js:24:1 => 1 2\n * // in 0.998 secs\n * ```\n *\n * and just to demonstrate all the location variables in one custom format:\n * ```js\n * logAF.options({\n *   labelFormat: ({arrow, line, col, parent, file, path}) =>\n * `${arrow}\n * line: ${line}\n * col: ${col}\n * parent: ${parent}\n * file: ${file}\n * path: ${path}\n * `\n * });\n * logAF(promise, 2);\n *\n * // ========================>\n * // line: 24\n * // col: 1\n * // parent: parentDirectory/\n * // file: filename.js\n * // path: /Full/path/to/the/parentDirectory/\n * // 1 2\n * // in 0.998 secs\n * ```\n *\n * to reset `logAF.options` to its default values, call `logAF.options.reset`\n * ```js\n * logAF.options.reset();\n *\n * // options are now:\n * // label: true,\n * // duration: true,\n * // labelFormat: 'file'\n * ```\n *\n * @static\n * @param {Object} options the options for logAF\n * @param {Boolean} [options.label=true] set to false to turn off the label\n * @param {Boolean} [options.duration=true] set to false to turn off duration\n * @param {String|Function} [options.labelFormat=file] see examples for sample label formats\n * @returns {undefined} sets the options for logAF\n * @see {@link AsyncAF#logAF logAF}\n * @see logAF.options.reset to reset options to default\n * @memberof AsyncAF\n * @alias AsyncAF#logAF_options\n */\nconst logAfOptions = (options = {}) => {\n  const {label, duration, labelFormat} = options;\n  if (typeof label === 'boolean') logAF.label = label;\n  if (typeof duration === 'boolean') logAF.duration = duration;\n  if (labelFormat)\n    if (typeof labelFormat === 'string' || typeof labelFormat === 'function')\n      logAF.labelFormat = labelFormat;\n    else\n      logAF.wrappedWarn('Warning: logAF labelFormat option must be set to \\'file\\' (default), \\'path\\', \\'parent\\', \\'arrow\\', or a custom string or function\\n');\n};\n\nexport default logAfOptions;\n","const permissiveIsArrayLike = function (obj) {\n  return Array.isArray(obj) || (obj != null && obj.length != null);\n};\n\nexport default permissiveIsArrayLike;\n","const promiseAllWithHoles = promises => new Promise((resolve, reject) => {\n  const length = promises.length >>> 0;\n  const result = Array(length);\n  let pending = length;\n  let i = length;\n  if (!length) return resolve(result);\n  const settlePromise = i => Promise.resolve(promises[i]).then(value => {\n    if (i in promises) result[i] = value;\n    if (!--pending) resolve(result);\n  }, reject);\n  while (i--) settlePromise(i);\n});\n\nexport default promiseAllWithHoles;\n","import promiseAllWithHoles from './promiseAllWithHoles';\n\nconst serial = arr => (function resolveSerially(resolved, i) {\n  const {length} = resolved;\n  if (!length) return Promise.resolve(resolved);\n  const hole = !(i in arr);\n  return Promise.resolve(arr[i]).then(el => {\n    if (!hole) resolved[i] = el;\n    if (i === length - 1) return resolved;\n    return resolveSerially(resolved, i + 1);\n  });\n}(Array(arr.length >>> 0), 0));\n\nconst parallel = (arr, mapper, thisArg = undefined) => promiseAllWithHoles(arr, el => el)\n  .then(!mapper ? undefined : arr => promiseAllWithHoles(\n    Array.prototype.map.call(arr, mapper, thisArg),\n  ));\n\nexport {\n  serial,\n  parallel,\n};\n","import permissiveIsArrayLike from '../_internal/permissiveIsArrayLike';\nimport {parallel} from '../_internal/resolve';\n\n/**\n * joins all elements of an array or array-like object into a string and resolves to that string\n *\n * @param {any} separator the string that separates each element in the resulting string; defaults to `','`; non-string separators will be converted to strings if necessary; if `separator` is an empty string `''`, the array elements are joined without any characters between them\n * @returns {Promise.<String>} `Promise` that resolves to a string with all array elements joined; if array.length is `0`, an empty string `''` is returned\n * @example\n *\n * const animals = ['cow', 'chicken', 'cat', 'dog'].map(a => Promise.resolve(a));\n *\n * // joinAF separator defaults to ','\n * AsyncAF(animals).joinAF(); // Promise that resolves to 'cow,chicken,cat,dog'\n *\n * // specifying separator\n * AsyncAF(animals).joinAF(' & '); // Promise that resolves to 'cow & chicken & cat & dog'\n *\n * // a non-string separator will be converted to a string\n * AsyncAF(animals).joinAF(2); // Promise that resolves to 'cow2chicken2cat2dog'\n *\n * // empty string separator\n * AsyncAF(animals).joinAF(''); // Promise that resolves to 'cowchickencatdog'\n *\n * // joining an empty array resolves to an empty string\n * AsyncAF([]).joinAF('+'); // Promise that resolves to ''\n *\n * // joinAF on an array-like object\n * (async function () {\n *  const list = await AsyncAF(arguments).joinAF(' - ');\n *  console.log(`Shopping List: ${list}`);\n * })('eggs', 'milk', 'butter', 'pancake mix');\n * // Shopping List: eggs - milk - butter - pancake mix\n *\n * @since 3.6.0\n * @see join (alias)\n * @memberof AsyncAF#\n */\nconst joinAF = function (separator = ',') {\n  return this.then(arr => {\n    if (!permissiveIsArrayLike(arr)) throw TypeError(\n      `joinAF cannot be called on ${arr}, only on an Array or array-like Object`,\n    );\n    return parallel(arr).then(arr => arr.join(separator));\n  });\n};\n\nObject.defineProperty(joinAF, 'length', {value: 1});\n\nexport default joinAF;\n","const resolveByType = data => Promise[Array.isArray(data) ? 'all' : 'resolve'](data);\n\n/**\n * merges an array or string with one or more arrays, strings, or other values, and resolves to a new array or string;\n *\n * concatAF flexibly accepts arrays, strings, promises, other values, or other instances of AsyncAF; see examples\n *\n * @param {any} values arrays, strings, or values to concatenate into a new array or string\n *  - if any values are a Promise, they'll first be resolved then concatenated\n *  - if any values are an instance of AsyncAF, they'll be merged into one instance\n * @returns {Promise.<Array>|Promise.<String>} `Promise` that resolves to a newly merged array or string\n * @example\n *\n * // arrays\n * const arr = Promise.resolve([1, 2]);\n * AsyncAF(arr).concatAF([3, 4]); // Promise that resolves to [1, 2, 3, 4]\n * AsyncAF(arr).concatAF([3, 4], [5, 6]); // Promise that resolves to [1, 2, 3, 4, 5, 6]\n *\n * // nested arrays\n * const arr1 = Promise.resolve([1, 2]);\n * const arr2 = [3, [4, 5]];\n * AsyncAF(arr1).concatAF(arr2); // Promise that resolves to [1, 2, 3, [4, 5]]\n *\n * // strings\n * const str = Promise.resolve('str');\n * AsyncAF(str).concatAF('ing'); // Promise that resolves to 'string'\n * AsyncAF(str).concatAF('ing', 'y'); // Promise that resolves to 'stringy'\n *\n * // other instances of AsyncAF\n * const aaf1 = AsyncAF([1, 2]);\n * const aaf2 = AsyncAF(3);\n *\n * aaf1.concatAF(aaf2); // Promise that resolves to [1, 2, 3];\n *\n * const aaf3 = AsyncAF('stringy');\n * const aaf4 = AsyncAF('AF');\n *\n * aaf3.concatAF(aaf4); // Promise that resolves to 'stringyAF'\n *\n * // promises\n * const [p1, p2, p3] = [[1, 2], 3, [4, [5, 6]]].map(v => Promise.resolve(v));\n *\n * AsyncAF(p1).concatAF(p2); // Promise that resolves to [1, 2, 3]\n * AsyncAF(p1).concatAF(p2, p3) // Promise that resolves to [1, 2, 3, 4, [5, 6]]\n *\n * const pStr1 = Promise.resolve('str');\n * const pStr2 = Promise.resolve('ing');\n * const pStr3 = Promise.resolve('y');\n *\n * AsyncAF(pStr1).concatAF(pStr2); // Promise that resolves to 'string'\n * AsyncAF(pStr1).concatAF(pStr2, pStr3); // Promise that resolves to 'stringy'\n *\n * // Note: concatAF will not resolve deeply nested promises; if you need this behavior, concatAF can be used in a\n * // function; for example, this function recursively flattens an array of promises\n *\n * const flattenAsync = arr => AsyncAF(arr).reduceAF(async (acc, val) => {\n *   return Array.isArray(await val)\n *     ? AsyncAF(acc).concatAF(flattenAsync(val))\n *     : AsyncAF(acc).concatAF(val), []);\n * };\n *\n * @since 5.3.0\n * @see concat (alias)\n * @memberof AsyncAF#\n */\nconst concatAF = function (...values) {\n  const isThenable = value => [Promise, this.constructor]\n    .some(thenable => value instanceof thenable);\n  const concat = (arrOrStr, value) => (\n    isThenable(value) && value.then(resolveByType).then(value => arrOrStr.concat(value))\n  ) || arrOrStr.concat(value);\n  return this.then(arrOrStr => {\n    if (!(typeof arrOrStr === 'string' || Array.isArray(arrOrStr))) throw TypeError(\n      `concatAF cannot be called on ${arrOrStr}, only on an Array or String`,\n    );\n    return resolveByType(arrOrStr).then(arrOrStr => values.reduce((arrOrStr, value) => (\n      isThenable(arrOrStr)\n        ? arrOrStr.then(arrOrStr => concat(arrOrStr, value))\n        : concat(arrOrStr, value)\n    ), arrOrStr));\n  });\n};\n\nexport default concatAF;\n","import name from './lib/methods/_internal/nameFunction';\n\n/* eslint-disable import/first */\nconst libName = 'async-af';\nconst libPath = './lib/';\n\nconst makeScoped = name => `@${libName}/${name.replace(/AsyncAf|AF/g, '').toLowerCase()}`;\n\n/* ____________________________\n  |           CLASSES          |\n  |____________________________| */\n\nconst classPath = `${libPath}classes/`;\n\nconst classes = [\n  [{name: 'AsyncAF'}, `${classPath}AsyncAF`, libName],\n  [{name: 'AsyncAfWrapper'}, `${classPath}AsyncAfWrapper`, makeScoped('AsyncAfWrapper')],\n];\n\n/* ____________________________\n  |       STATIC METHODS       |\n  |____________________________| */\n\nimport logAF from './lib/methods/other/logAF';\n\nconst staticMethods = [\n  name(logAF, 'logAF'),\n].map(method => [\n  method,\n  `${libPath}methods/other/${method.name}`,\n  makeScoped(method.name),\n]);\n\n/* ____________________________\n  |      PROTOTYPE METHODS     |\n  |____________________________| */\n\n// Arrays\nimport mapAF from './lib/methods/arrays/mapAF';\nimport forEachAF from './lib/methods/arrays/forEachAF';\nimport filterAF from './lib/methods/arrays/filterAF';\nimport reduceAF from './lib/methods/arrays/reduceAF';\nimport everyAF from './lib/methods/arrays/everyAF';\nimport someAF from './lib/methods/arrays/someAF';\nimport includesAF from './lib/methods/arrays/includesAF';\nimport findAF from './lib/methods/arrays/findAF';\nimport findIndexAF from './lib/methods/arrays/findIndexAF';\nimport indexOfAF from './lib/methods/arrays/indexOfAF';\nimport lastIndexOfAF from './lib/methods/arrays/lastIndexOfAF';\nimport joinAF from './lib/methods/arrays/joinAF';\nimport concatAF from './lib/methods/arrays/concatAF';\n\nconst arrayMethods = [\n  name(mapAF, 'mapAF'),\n  name(forEachAF, 'forEachAF'),\n  name(filterAF, 'filterAF'),\n  name(reduceAF, 'reduceAF'),\n  name(everyAF, 'everyAF'),\n  name(someAF, 'someAF'),\n  name(includesAF, 'includesAF'),\n  name(findAF, 'findAF'),\n  name(findIndexAF, 'findIndexAF'),\n  name(indexOfAF, 'indexOfAF'),\n  name(lastIndexOfAF, 'lastIndexOfAF'),\n  name(joinAF, 'joinAF'),\n  name(concatAF, 'concatAF'),\n].map(method => [\n  method,\n  `${libPath}methods/arrays/${method.name}`,\n  makeScoped(method.name),\n]);\n\n// strings\nimport splitAF from './lib/methods/strings/splitAF';\n\nconst stringMethods = [\n  name(splitAF, 'splitAF'),\n].map(method => [\n  method,\n  `${libPath}methods/strings/${method.name}`,\n  makeScoped(method.name),\n]);\n\nconst prototypeMethods = [\n  ...arrayMethods,\n  ...stringMethods,\n];\n\n/* ____________________________\n  |         COLLECTIONS        |\n  |____________________________| */\n\n// import arrays from './lib/collections/arrays';\n\nconst collections = [\n  // arrays,\n];\n\nexport default [\n  ...classes,\n  ...staticMethods,\n  ...prototypeMethods,\n  ...collections,\n];\n\nconst pluckMethods = packages => packages.map(([method]) => method);\n\nconst staticMethodsOnly = pluckMethods(staticMethods);\nconst prototypeMethodsOnly = pluckMethods(prototypeMethods);\n\nexport {\n  staticMethodsOnly as staticMethods,\n  prototypeMethodsOnly as prototypeMethods,\n  makeScoped,\n};\n","import callback from '../_internal/commonCallback'; // eslint-disable-line no-unused-vars\nimport permissiveIsArrayLike from '../_internal/permissiveIsArrayLike';\nimport promiseAllWithHoles from '../_internal/promiseAllWithHoles';\nimport {parallel, serial} from '../_internal/resolve';\n\n/**\n * creates a new `Array` with the results of calling a provided function on every element in the original array\n *\n * if any elements are a `Promise`, they will first be resolved in parallel and then processed\n *\n * *Note*: if you'd rather resolve and process elements in series, consider using `series.mapAF` or its alias, `io.mapAF`\n *\n * @param {callback} callback function that produces an element of the new `Array`\n *\n * `callback` accepts three arguments:\n * - `currentValue` value of the current element being processed in the array\n * - `index`*`(optional)`* index of `currentValue` in the array\n * - `array`*`(optional)`* the array that mapAF is being applied to\n * @param {Object=} thisArg value to use as `this` when executing `callback`\n * @returns {Promise.<Array>} `Promise` that resolves to a new `Array` with each element being the result of calling `callback` on each original element\n * @example\n *\n * const promises = [1, 2].map(n => Promise.resolve(n));\n *\n *\n * // basic usage\n * const doubled = AsyncAF(promises).mapAF(el => el * 2);\n *\n * console.log(doubled); // Promise that resolves to [2, 4]\n *\n * AsyncAF.logAF(doubled); // logs [2, 4]\n *\n *\n * // using .then\n * AsyncAF(promises).mapAF(el => el * 3).then(tripled => {\n *   console.log(tripled); // logs [3, 6]\n * });\n *\n *\n * // inside an async function\n * (async () => {\n *   const quadrupled = await AsyncAF(promises).mapAF(\n *     el => el * 4\n *   );\n *   console.log(quadrupled); // logs [4, 8]\n * })();\n * @since 3.0.0\n * @see map (alias)\n * @see {@link AsyncAF#series series.mapAF}\n * @memberof AsyncAF#\n */\nconst mapAF = function (callback, thisArg = undefined) {\n  return this.then(arr => {\n    if (!permissiveIsArrayLike(arr)) throw TypeError(\n      `mapAF cannot be called on ${arr}, only on an Array or array-like Object`,\n    );\n    if (typeof callback !== 'function') throw TypeError(`${callback} is not a function`);\n    return this.inSeries\n      ? serial(arr).then(arr => arr.reduce((map, el, i, arr) => map.then(map => {\n        map[i] = Promise.resolve(callback.call(thisArg, el, i, arr));\n        return promiseAllWithHoles(map);\n      }), Promise.resolve(Array(arr.length >>> 0))))\n      : parallel(arr, callback, thisArg);\n  });\n};\n\nexport default mapAF;\n","import callback from '../_internal/commonCallback'; // eslint-disable-line no-unused-vars\nimport permissiveIsArrayLike from '../_internal/permissiveIsArrayLike';\nimport {parallel, serial} from '../_internal/resolve';\n\n/**\n * executes a callback function on each element in an array\n *\n * if any elements are a `Promise`, they will first be resolved in parallel and then processed\n *\n * *Note*: if you'd rather resolve and process elements in series, consider using `series.forEachAF` or its alias, `io.forEachAF`\n *\n * @param {callback} callback function to execute for each element\n *\n * `callback` accepts three arguments:\n * - `currentValue` value of the current element being processed in the array\n * - `index`*`(optional)`* index of `currentValue` in the array\n * - `array`*`(optional)`* the array that forEachAF is being applied to\n * @param {Object=} thisArg value to use as `this` when executing `callback`\n * @returns {Promise.<undefined>} `Promise` that resolves to `undefined`\n * @example\n *\n * const promises = [1, 2].map(n => Promise.resolve(n));\n *\n *\n * AsyncAF(promises).forEachAF(el => {\n *   console.log(el); // logs 1 then 2\n * });\n * @since 3.0.0\n * @see forEach (alias)\n * @see {@link AsyncAF#series series.forEachAF}\n * @memberof AsyncAF#\n */\nconst forEachAF = function (callback, thisArg = undefined) {\n  return this.then(arr => {\n    if (!permissiveIsArrayLike(arr)) throw TypeError(\n      `forEachAF cannot be called on ${arr}, only on an Array or array-like Object`,\n    );\n    if (typeof callback !== 'function') throw TypeError(`${callback} is not a function`);\n    return (this.inSeries\n      ? serial(arr).then(arr => arr.reduce((expr, el, i, arr) => expr.then(() => (\n        Promise.resolve(callback.call(thisArg, el, i, arr))\n      )), Promise.resolve()))\n      : parallel(arr, callback, thisArg)\n    ).then(() => {});\n  });\n};\n\nexport default forEachAF;\n","import callback from '../_internal/commonCallback'; // eslint-disable-line no-unused-vars\nimport permissiveIsArrayLike from '../_internal/permissiveIsArrayLike';\nimport {parallel, serial} from '../_internal/resolve';\n\n/**\n * creates a new `Array` with all elements that pass the test implemented by the provided callback function\n *\n * if any elements are a `Promise`, they will first be resolved in parallel and then tested\n *\n * *Note*: if you'd rather resolve and test elements in series, consider using `series.filterAF` or its alias, `io.filterAF`\n *\n * @param {callback} callback function that tests each element of the array; return `true` to keep the element, `false` to filter it out\n *\n * `callback` accepts three arguments:\n * - `currentValue` value of the current element being processed in the array\n * - `index`*`(optional)`* index of `currentValue` in the array\n * - `array`*`(optional)`* the array that `filterAF` is being applied to\n * @param {Object=} thisArg value to use as `this` when executing `callback`\n * @returns {Promise.<Array>} `Promise` that resolves to a new `Array` with the elements that pass the test; if no elements pass the test, the promise will resolve to an empty array\n * @example\n *\n * const promises = [1, 2, 3].map(n => Promise.resolve(n));\n *\n *\n * // basic usage\n * const odds = AsyncAF(promises).filterAF(n => n % 2);\n *\n * console.log(odds); // Promise that resolves to [1, 3]\n *\n * AsyncAF.logAF(odds); // logs [1, 3]\n *\n *\n * // using .then\n * AsyncAF(promises).filterAF(n => n % 2).then(odds => {\n *   console.log(odds); // logs [1, 3]\n * });\n *\n *\n * // inside an async function\n * (async () => {\n *   const odds = await AsyncAF(promises).filterAF(\n *     n => n % 2\n *   );\n *   console.log(odds); // logs [1, 3]\n * })();\n * @since 3.0.0\n * @see filter (alias)\n * @see {@link AsyncAF#series series.filterAF}\n * @memberof AsyncAF#\n */\nconst filterAF = function (callback, thisArg = undefined) {\n  return this.then(arr => {\n    if (!permissiveIsArrayLike(arr)) throw TypeError(\n      `filterAF cannot be called on ${arr}, only on an Array or array-like Object`,\n    );\n    if (typeof callback !== 'function') throw TypeError(`${callback} is not a function`);\n    return (this.inSeries ? serial : parallel)(arr).then(arr => (\n      this.inSeries\n        ? arr.reduce((bools, el, i, arr) => bools.then(bools => {\n          bools[i] = callback.call(thisArg, el, i, arr);\n          return Promise.all(bools);\n        }), Promise.all([]))\n        : parallel(arr, callback, thisArg)\n    ).then(bools => arr.filter((_, i) => bools[i])));\n  });\n};\n\nexport default filterAF;\n","import callback from '../_internal/reduceCallback'; // eslint-disable-line no-unused-vars\nimport permissiveIsArrayLike from '../_internal/permissiveIsArrayLike';\nimport {parallel, serial} from '../_internal/resolve';\n\n/* eslint-disable prefer-rest-params */\n/**\n * applies a function against an accumulator and each element in an array (from left to right) to reduce it to a single value\n *\n * if any elements are a `Promise`, they will first be resolved in parallel and then processed in series\n *\n * *Note*: if this behavior is not desirable, consider using `series.reduceAF` or its alias, `io.reduceAF`; that way, if any elements are a `Promise`, they will both be resolved in series _and_ processed in series\n *\n * @param {callback} callback function to execute for each element\n *\n * `callback` accepts up to four arguments:\n * - `accumulator` accumulates the callback's return values; the accumulated value previously returned in the last invocation of the callback, or initialValue, if supplied\n * - `currentValue` value of the current element being processed in the array\n * - `index`*`(optional)`* index of `currentValue` in the array\n * - `array`*`(optional)`* the array that `reduceAF` is being applied to\n * @param {any=} initialValue value to use as the first argument to the first call of the callback; if no initial value is supplied, the first element in the array will be used; note: calling reduceAF on an empty array with no initial value will throw an error\n * @returns {Promise.<any>} `Promise` that resolves to the reduced value\n * @example\n *\n * const promises = [1, 2, 3].map(n => Promise.resolve(n));\n *\n *\n * // basic usage\n * const sum = AsyncAF(promises).reduceAF((sum, num) => sum + num);\n *\n * console.log(sum); // Promise that resolves to 6\n *\n * AsyncAF.logAF(sum); // logs 6\n *\n *\n * // using .then\n * AsyncAF(promises).reduceAF((sum, num) => sum + num).then(sum => {\n *   console.log(sum); // logs 6\n * });\n *\n *\n * // inside an async function\n * (async () => {\n *   const sum = await AsyncAF(promises).reduceAF((sum, num) => sum + num);\n *   console.log(sum); // logs 6\n * })();\n *\n *\n * // using an initial value\n * AsyncAF(promises).reduceAF((sum, num) => sum + num, 12) // Promise that resolves to 18\n * @since 3.1.0\n * @see reduce (alias)\n * @see {@link AsyncAF#series series.reduceAF}\n * @memberof AsyncAF#\n */\nconst reduceAF = function (callback/* , initialValue */) {\n  return this.then(arr => {\n    if (!permissiveIsArrayLike(arr)) throw TypeError(\n      `reduceAF cannot be called on ${arr}, only on an Array or array-like Object`,\n    );\n    if (typeof callback !== 'function') throw TypeError(`${callback} is not a function`);\n    const length = arr.length >>> 0;\n    if (!length && arguments.length === 1) throw TypeError(\n      'reduceAF cannot be called on an empty array without an initial value',\n    );\n    if (!length) return arguments[1];\n    const hole = i => !(i in arr);\n    let i = 0;\n    let acc;\n    if (arguments.length === 2) {\n      [, acc] = arguments;\n    } else {\n      while (hole(i)) i++;\n      acc = arr[i++];\n    }\n    return (this.inSeries ? serial : parallel)(arr).then(arr => {\n      const reduceAF = (acc, i) => Promise.resolve(acc).then(acc => Promise.resolve(\n        !hole(i) ? callback(acc, arr[i], i, arr) : acc,\n      ).then(acc => i === length - 1 ? acc : reduceAF(acc, i + 1)));\n      return reduceAF(acc, i);\n    });\n  });\n};\n\nexport default reduceAF;\n","import callback from '../_internal/commonCallback'; // eslint-disable-line no-unused-vars\nimport permissiveIsArrayLike from '../_internal/permissiveIsArrayLike';\nimport {parallel} from '../_internal/resolve';\n\n/**\n * tests whether all elements in the array pass the test implemented by the provided callback function\n *\n * if any elements are a `Promise`, they will first be resolved in parallel and then tested\n *\n * *Note*: since `everyAF` is run in parallel, `callback` will be run on all elements even if one of the first few elements fails the test; if this behavior is not desireable, consider using `series.everyAF` or its alias, `io.everyAF`\n *\n * @param {callback} callback function that tests each element of the array\n *\n * `callback` accepts three arguments:\n * - `currentValue` value of the current element being processed in the array\n * - `index`*`(optional)`* index of `currentValue` in the array\n * - `array`*`(optional)`* the array that `everyAF` is being applied to\n * @param {Object=} thisArg value to use as `this` when executing `callback`\n * @returns {Promise.<Boolean>} `Promise` that resolves to `true` if the callback function returns a truthy value for every array element; otherwise, `false`\n * @example\n *\n * const promises = [1, 2, 3].map(n => Promise.resolve(n));\n *\n *\n * // basic usage\n * const allAreOdd = AsyncAF(promises).everyAF(n => n % 2);\n *\n * console.log(allAreOdd); // Promise that resolves to false\n *\n * AsyncAF.logAF(allAreOdd); // logs false\n *\n *\n * // using .then\n * AsyncAF(promises).everyAF(n => n % 2).then(allAreOdd => {\n *   console.log(allAreOdd); // logs false\n * });\n *\n *\n * // inside an async function\n * (async () => {\n *   const allAreNums = await AsyncAF(promises).everyAF(\n *     n => typeof n === 'number'\n *   );\n *   console.log(allAreNums); // logs true\n * })();\n * @since 3.2.0\n * @see every (alias)\n * @see {@link AsyncAF#series series.everyAF}\n * @memberof AsyncAF#\n */\nconst everyAF = function (callback, thisArg = undefined) {\n  return this.then(arr => {\n    if (!permissiveIsArrayLike(arr)) throw TypeError(\n      `everyAF cannot be called on ${arr}, only on an Array or array-like Object`,\n    );\n    if (typeof callback !== 'function') throw TypeError(`${callback} is not a function`);\n    const length = arr.length >>> 0;\n    return this.inSeries\n      ? (!length && true) || (function seriesEveryAF(arr, i) {\n        const hole = !(i in arr);\n        return Promise.resolve(arr[i]).then(el => {\n          arr[i] = el;\n          return Promise.resolve(!hole && callback.call(thisArg, el, i, arr))\n            .then(bool => {\n              if (!bool && !hole) return false;\n              if (i === length - 1) return true;\n              return seriesEveryAF(arr, i + 1);\n            });\n        });\n      }(Array.prototype.slice.call(arr), 0))\n      : parallel(arr, callback, thisArg).then(bools => bools.every(Boolean));\n  });\n};\n\nexport default everyAF;\n","import callback from '../_internal/commonCallback'; // eslint-disable-line no-unused-vars\nimport permissiveIsArrayLike from '../_internal/permissiveIsArrayLike';\nimport {parallel} from '../_internal/resolve';\n\n/**\n * tests whether at least one element in the array passes the test implemented by the provided callback function\n *\n * if any elements are a `Promise`, they will first be resolved in parallel and then tested\n *\n * *Note*: since `someAF` is run in parallel, `callback` will be run on all elements even if one of the first few elements passes the test; if this behavior is not desireable, consider using `series.someAF` or its alias, `io.someAF`\n *\n * @param {callback} callback function that tests each element of the array\n *\n * `callback` accepts three arguments:\n * - `currentValue` value of the current element being processed in the array\n * - `index`*`(optional)`* index of `currentValue` in the array\n * - `array`*`(optional)`* the array that `someAF` is being applied to\n * @param {Object=} thisArg value to use as `this` when executing `callback`\n * @returns {Promise.<Boolean>} `Promise` that resolves to `true` if the callback function returns a truthy value for any array element; otherwise, `false`\n * @example\n *\n * const promises = [1, 2, 3].map(n => Promise.resolve(n));\n *\n *\n * // basic usage\n * const someAreEven = AsyncAF(promises).someAF(n => n % 2 === 0);\n *\n * console.log(someAreEven); // Promise that resolves to true\n *\n * AsyncAF.logAF(someAreEven); // logs true\n *\n *\n * // using .then\n * AsyncAF(promises).someAF(n => n % 2 === 0).then(someAreEven => {\n *   console.log(someAreEven); // logs true\n * });\n *\n *\n * // inside an async function\n * (async () => {\n *   const someAreStrings = await AsyncAF(promises).someAF(\n *     n => typeof n === 'string'\n *   );\n *   console.log(someAreStrings); // logs false\n * })();\n * @since 3.3.0\n * @see some (alias)\n * @see {@link AsyncAF#series series.someAF}\n * @memberof AsyncAF#\n */\nconst someAF = function (callback, thisArg = undefined) {\n  return this.then(arr => {\n    if (!permissiveIsArrayLike(arr)) throw TypeError(\n      `someAF cannot be called on ${arr}, only on an Array or array-like Object`,\n    );\n    if (typeof callback !== 'function') throw TypeError(`${callback} is not a function`);\n    const length = arr.length >>> 0;\n    return this.inSeries\n      ? (length || false) && (function seriesSomeAF(arr, i) {\n        const hole = !(i in arr);\n        return Promise.resolve(arr[i]).then(el => {\n          arr[i] = el;\n          return Promise.resolve(!hole && callback.call(thisArg, el, i, arr))\n            .then(bool => {\n              if (bool && !hole) return true;\n              if (i === length - 1) return false;\n              return seriesSomeAF(arr, i + 1);\n            });\n        });\n      }(Array.prototype.slice.call(arr), 0))\n      : parallel(arr, callback, thisArg).then(bools => bools.some(Boolean));\n  });\n};\n\nexport default someAF;\n","import permissiveIsArrayLike from '../_internal/permissiveIsArrayLike';\nimport {parallel} from '../_internal/resolve';\n\nconst sameValueZero = (a, b) => a === b || (Number.isNaN(a) && Number.isNaN(b));\n\n/**\n * determines whether an array, string, or array-like object includes a certain element or string, returning true or false as appropriate\n *\n * *Note*: when called on an array or array-like object, `includesAF` is run in parallel and all elements will be resolved even if one of the first few elements is a match; if this behavior is not desireable, consider using `series.includesAF` or its alias, `io.includesAF`\n *\n * @param {any} searchItem the element or string to search for\n * @param {Number=} fromIndex the index at which to begin searching for `searchItem`; a negative value searches from the index of `array/string.length - fromIndex`; defaults to `0`\n * @returns {Promise.<Boolean>} `Promise` that resolves to `true` if `searchItem` is found; otherwise, `false`\n * @example\n *\n * // includesAF on an array of promises\n * const nums = [1, 2, 3].map(n => Promise.resolve(n));\n *\n * AsyncAF(nums).includesAF(2); // Promise that resolves to true\n *\n * AsyncAF(nums).includesAF(5); // Promise that resolves to false\n *\n * AsyncAF(nums).includesAF(1, 1); // Promise that resolves to false\n *\n * AsyncAF(nums).includesAF(3, -1); // Promise that resolves to true\n *\n * // includesAF on a promise-wrapped string\n * const string = Promise.resolve('test string');\n *\n * AsyncAF(string).includesAF('test'); // Promise that resolves to true\n *\n * AsyncAF(string).includesAF('nope'); // Promise that resolves to false\n *\n * AsyncAF(string).includesAF('test', 5); // Promise that resolves to false\n *\n * AsyncAF(string).includesAF('string', -6); // Promise that resolves to true\n *\n * // includesAF on an array-like object\n * (async function () {\n *   if (await AsyncAF(arguments).includesAF(2)) {\n *     console.log('2 is included');\n *   }\n * })(1, 2, 3); // logs '2 is included'\n *\n * @since 3.4.0\n * @see includes (alias)\n * @see {@link AsyncAF#series series.includesAF}\n * @memberof AsyncAF#\n */\nconst includesAF = function (searchItem, fromIndex = 0) {\n  return this.then(arrOrStr => {\n    if (!permissiveIsArrayLike(arrOrStr)) throw TypeError(\n      `includesAF cannot be called on ${arrOrStr}, only on an Array, String, or array-like Object`,\n    );\n    const length = arrOrStr.length >>> 0;\n    const fromIdx = fromIndex | 0;\n    return typeof arrOrStr === 'string'\n      ? arrOrStr.includes(searchItem, fromIdx)\n      : this.inSeries\n        ? (length || false) && (function seriesIncludesAF(i) {\n          return Promise.resolve(arrOrStr[i]).then(el => {\n            if (sameValueZero(el, searchItem)) return true;\n            if (i >= length - 1) return false;\n            return seriesIncludesAF(i + 1);\n          });\n        }(Math.max(fromIdx >= 0 ? fromIdx : length - Math.abs(fromIdx), 0)))\n        : parallel(arrOrStr).then(arr => arr.includes(searchItem, fromIdx));\n  });\n};\n\nexport default includesAF;\n","import callback from '../_internal/commonCallback'; // eslint-disable-line no-unused-vars\nimport permissiveIsArrayLike from '../_internal/permissiveIsArrayLike';\nimport {parallel} from '../_internal/resolve';\n\n/**\n * resolves to the value of the first element in the array that satisfies the provided callback function; otherwise, `undefined`\n *\n * *Note*: since `findAF` is run in parallel, `callback` will be run on all elements even if one of the first few elements passes the test; if this behavior is not desireable, consider using `series.findAF` or its alias, `io.findAF`\n *\n * @param {callback} callback function to test each element in the array\n *\n * `callback` accepts three arguments:\n * - `currentValue` value of the current element being processed in the array\n * - `index`*`(optional)`* index of `currentValue` in the array\n * - `array`*`(optional)`* the array that findAF is being applied to\n * @param {Object=} thisArg value to use as `this` when executing `callback`\n * @returns {Promise.<any>} `Promise` that resolves to the first element in the array that passes the test; otherwise, undefined\n * @example\n *\n * const inventory = [\n *  {name: 'nuts', quantity: 2000},\n *  {name: 'bolts', quantity: 5000},\n *  {name: 'screws', quantity: 9001}\n * ].map(part => Promise.resolve(part));\n *\n * AsyncAF(inventory).findAF(part => part.name === 'screws');\n * // Promise that resolves to {name: 'screws', quantity: 9001}\n * @since 3.5.0\n * @see find (alias)\n * @see {@link AsyncAF#series series.findAF}\n * @memberof AsyncAF#\n */\nconst findAF = function (callback, thisArg = undefined) {\n  return this.then(arr => {\n    if (!permissiveIsArrayLike(arr)) throw TypeError(\n      `findAF cannot be called on ${arr}, only on an Array or array-like Object`,\n    );\n    if (typeof callback !== 'function') throw TypeError(`${callback} is not a function`);\n    const filled = Array.from(arr);\n    const length = filled.length >>> 0;\n    return this.inSeries\n      ? (length || undefined) && (function seriesFindAF(arr, i) {\n        return Promise.resolve(arr[i]).then(el => {\n          arr[i] = el;\n          return Promise.resolve(callback.call(thisArg, el, i, arr)).then(bool => {\n            if (bool) return el;\n            if (i === length - 1) return;\n            return seriesFindAF(arr, i + 1);\n          });\n        });\n      }(filled, 0))\n      : parallel(filled, callback, thisArg).then(bools => arr[bools.indexOf(true)]);\n  });\n};\n\nexport default findAF;\n","import callback from '../_internal/commonCallback'; // eslint-disable-line no-unused-vars\nimport permissiveIsArrayLike from '../_internal/permissiveIsArrayLike';\nimport {parallel} from '../_internal/resolve';\n\n/**\n * resolves to the index of the first element in the array that satisfies the provided callback function; otherwise, `-1`\n *\n * *Note*: since `findIndexAF` is run in parallel, `callback` will be run on all indices even if one of the first few indices passes the test; if this behavior is not desireable, consider using `series.findIndexAF` or its alias, `io.findIndexAF`\n *\n * @param {callback} callback function to test each element in the array\n *\n * `callback` accepts three arguments:\n * - `currentValue` value of the current element being processed in the array\n * - `index`*`(optional)`* index of `currentValue` in the array\n * - `array`*`(optional)`* the array that findIndexAF is being applied to\n * @param {Object=} thisArg value to use as `this` when executing `callback`\n * @returns {Promise.<Number>} `Promise` that resolves to the index of the first element in the array that passes the test; otherwise, `-1`\n * @example\n *\n * const inventory = [\n *  {name: 'nuts', quantity: 2000},\n *  {name: 'bolts', quantity: 5000},\n *  {name: 'screws', quantity: 9001}\n * ].map(part => Promise.resolve(part));\n *\n * AsyncAF(inventory).findIndexAF(part => part.name === 'screws');\n * // Promise that resolves to 2\n * @since 3.5.0\n * @see findIndex (alias)\n * @see {@link AsyncAF#series series.findIndexAF}\n * @memberof AsyncAF#\n */\nconst findIndexAF = function (callback, thisArg = undefined) {\n  return this.then(arr => {\n    if (!permissiveIsArrayLike(arr)) throw TypeError(\n      `findIndexAF cannot be called on ${arr}, only on an Array or array-like Object`,\n    );\n    if (typeof callback !== 'function') throw TypeError(`${callback} is not a function`);\n    const filled = Array.from(arr);\n    const length = filled.length >>> 0;\n    return this.inSeries\n      ? (!length && -1) || (function seriesFindIndexAF(arr, i) {\n        return Promise.resolve(arr[i]).then(el => {\n          arr[i] = el;\n          return Promise.resolve(callback.call(thisArg, el, i, arr)).then(bool => {\n            if (bool) return i;\n            if (i === length - 1) return -1;\n            return seriesFindIndexAF(arr, i + 1);\n          });\n        });\n      }(filled, 0))\n      : parallel(filled, callback, thisArg).then(bools => bools.indexOf(true));\n  });\n};\n\nexport default findIndexAF;\n","import permissiveIsArrayLike from '../_internal/permissiveIsArrayLike';\nimport {parallel} from '../_internal/resolve';\n\n/**\n * resolves to the first index of the specified element or string in an array, string, or array-like object, starting the search at `fromIndex`; if the value is not found, resolves to `-1`\n *\n * *Note*: when called on an array or array-like object, `indexOfAF` is run in parallel and all elements will be resolved even if one of the first few indices is a match; if this behavior is not desireable, consider using `series.indexOfAF` or its alias, `io.indexOfAF`\n *\n * @param {any} searchItem the element or string to search for\n * @param {Number=} fromIndex the index at which to begin searching for `searchItem`; a negative value searches from the index of `array/string.length - fromIndex`; defaults to `0`\n * @returns {Promise.<Number>} `Promise` that resolves to the index of `searchItem` if found; otherwise, `-1`\n * @example\n *\n * // indexOfAF on an array of promises\n * const nums = [1, 2, 3].map(n => Promise.resolve(n));\n *\n * AsyncAF(nums).indexOfAF(2); // Promise that resolves to 1\n *\n * AsyncAF(nums).indexOfAF(5); // Promise that resolves to -1\n *\n * AsyncAF(nums).indexOfAF(1, 1); // Promise that resolves to -1\n *\n * AsyncAF(nums).indexOfAF(3, -1); // Promise that resolves to 2\n *\n * // indexOfAF on a promise-wrapped string\n * const string = Promise.resolve('test string');\n *\n * AsyncAF(string).indexOfAF('test'); // Promise that resolves to 0\n *\n * AsyncAF(string).indexOfAF('nope'); // Promise that resolves to -1\n *\n * AsyncAF(string).indexOfAF('test', 5); // Promise that resolves to -1\n *\n * AsyncAF(string).indexOfAF('string', -6); // Promise that resolves to 5\n *\n * // indexOfAF on an array-like object\n * (async function () {\n *   if (await AsyncAF(arguments).indexOfAF(2) > -1) {\n *     console.log('2 is included');\n *   }\n * })(1, 2, 3); // logs '2 is included'\n *\n * @since 3.5.0\n * @see indexOf (alias)\n * @see {@link AsyncAF#series series.indexOfAF}\n * @memberof AsyncAF#\n */\nconst indexOfAF = function (searchItem, fromIndex = 0) {\n  return this.then(arrOrStr => {\n    if (!permissiveIsArrayLike(arrOrStr)) throw TypeError(\n      `indexOfAF cannot be called on ${arrOrStr}, only on an Array, String, or array-like Object`,\n    );\n    const length = arrOrStr.length >>> 0;\n    const fromIdx = fromIndex | 0;\n    return typeof arrOrStr === 'string'\n      ? arrOrStr.indexOf(searchItem, fromIdx)\n      : this.inSeries\n        ? (function seriesIndexOfAF(i) {\n          return Promise.resolve(arrOrStr[i]).then(el => {\n            if (i in arrOrStr && el === searchItem) return i;\n            if (i >= length - 1) return -1;\n            return seriesIndexOfAF(i + 1);\n          });\n        }(Math.max(fromIdx >= 0 ? fromIdx : length - Math.abs(fromIdx), 0)))\n        : parallel(arrOrStr).then(arr => arr.indexOf(searchItem, fromIdx));\n  });\n};\n\nexport default indexOfAF;\n","import permissiveIsArrayLike from '../_internal/permissiveIsArrayLike';\nimport {parallel} from '../_internal/resolve';\n\n/**\n * resolves to the last index of the specified element or string, searching backwards in an array, string, or array-like object; `fromIndex` offsets the start of the search; if the value is not found, resolves to `-1`\n *\n * *Note*: when called on an array or array-like object, `lastIndexOfAF` is run in parallel and all elements will be resolved even if one of the last few indices is a match; if this behavior is not desireable, consider using `series.lastIndexOfAF` or its alias, `io.lastIndexOfAF`\n *\n * @param {any} searchItem the element or string to search for\n * @param {Number=} fromIndex the index at which to begin searching backwards for `searchItem`; a negative value searches from the index of `array/string.length - fromIndex`; defaults to `array/string.length - 1`\n * @returns {Promise.<Number>} `Promise` that resolves to the last index of `searchItem` if found; otherwise, `-1`\n * @example\n *\n * // lastIndexOfAF on an array of promises\n * const nums = [1, 1, 2, 2, 3, 3].map(n => Promise.resolve(n));\n *\n * AsyncAF(nums).lastIndexOfAF(2); // Promise that resolves to 3\n *\n * AsyncAF(nums).lastIndexOfAF(5); // Promise that resolves to -1\n *\n * AsyncAF(nums).lastIndexOfAF(2, -4); // Promise that resolves to 2\n *\n * AsyncAF(nums).lastIndexOfAF(3, -3); // Promise that resolves to -1\n *\n * // lastIndexOfAF on a promise-wrapped string\n * const string = Promise.resolve('test string to test');\n *\n * AsyncAF(string).lastIndexOfAF('test'); // Promise that resolves to 15\n *\n * AsyncAF(string).lastIndexOfAF('nope'); // Promise that resolves to -1\n *\n * AsyncAF(string).lastIndexOfAF('test', -5); // Promise that resolves to 0\n *\n * AsyncAF(string).lastIndexOfAF('to', -7); // Promise that resolves to -1\n *\n * // lastIndexOfAF on an array-like object\n * (async function () {\n *   const lastIndexOf2 = await AsyncAF(arguments).lastIndexOfAF(2);\n *   console.log(`the last index of 2 in the arguments array-like object is ${lastIndexOf2}`)\n * })(1, 1, 2, 2, 3, 3); // the last index of 2 in the arguments array-like object is 3\n *\n * @since 3.6.0\n * @see lastIndexOf (alias)\n * @see {@link AsyncAF#series series.lastIndexOfAF}\n * @memberof AsyncAF#\n */\nconst lastIndexOfAF = function (searchItem, fromIndex = undefined) {\n  return this.then(arrOrStr => {\n    if (!permissiveIsArrayLike(arrOrStr)) throw TypeError(\n      `lastIndexOfAF cannot be called on ${arrOrStr}, only on an Array, String, or array-like Object`,\n    );\n    const len = arrOrStr.length >>> 0;\n    let fromIdx = Number(fromIndex);\n    if (Number.isNaN(fromIdx)) fromIdx = len - 1;\n    return typeof arrOrStr === 'string'\n      ? arrOrStr.lastIndexOf(searchItem, fromIdx)\n      : this.inSeries\n        ? (function seriesLastIndexOfAF(i) {\n          return Promise.resolve(arrOrStr[i]).then(el => {\n            if (i in arrOrStr && el === searchItem) return i;\n            if (i <= 0) return -1;\n            return seriesLastIndexOfAF(i - 1);\n          });\n        }(Math.min(fromIdx >= 0 ? fromIdx : Math.max(len - Math.abs(fromIdx), 0), len - 1)))\n        : parallel(arrOrStr).then(arr => arr.lastIndexOf(searchItem, fromIdx));\n  });\n};\n\nexport default lastIndexOfAF;\n","/**\n * splits a string into an array of substrings, using a specified separator to determine where to make each split\n *\n * @param {String|RegExp=} separator a string or regular expression that denotes the points at which each split should occur\n * - if a plain-text separator contains more than one character, the entire separator must be found to represent a split point\n * - if separator is omitted or does not occur in the string, the array returned will contain one element consisting of the entire string\n * - if separator is an empty string, the string is converted to an array of individual characters\n * - if separator is a regular expression, the array returned will also contain any separators found as a result of matches within capturing parentheses\n * @param {Number=} limit integer specifying a limit on the number of elements to be included in the result; when provided, the string is split at each occurrence of the specified separator but stops including elements when the limit is reached (or the end of the string, if reached sooner); any left-over text is not included in the result\n * @returns {Promise.<String[]>} `Promise` that resolves to an array of strings, split at each point the separator occurs in the given string\n * @example\n *\n * // basic usage\n * const str = Promise.resolve('s; p; l; i; t');\n *\n * AsyncAF(str).splitAF('; '); // Promise that resolves to ['s', 'p', 'l', 'i', 't']\n *\n * // no separator specified or separator not found\n * const str = Promise.resolve('splat');\n *\n * AsyncAF(str).splitAF(); // Promise that resolves to ['splat']\n * AsyncAF(str).splitAF('n/a'); // Promise that resolves to ['splat']\n *\n * // split to individual characters\n * const str = Promise.resolve('splitAF');\n *\n * AsyncAF(str).splitAF(''); // Promise that resolves to ['s', 'p', 'l', 'i', 't', 'A', 'F']\n *\n * // split on a regular expression\n * const str = Promise.resolve('splittedAF');\n *\n * AsyncAF(str).splitAF(/sp|ted/); // Promise that resolves to ['', 'lit', 'AF']\n *\n * // and w/ capturing parentheses\n *\n * AsyncAF(str).splitAF(/(lit|AF)/); // Promise that resolves to ['sp', 'lit', '', 'AF', '']\n *\n * // setting limit\n * const str = Promise.resolve('splitted');\n *\n * AsyncAF(str).splitAF('', 5); // Promise that resolves to ['s', 'p', 'l', 'i', 't']\n * AsyncAF(str).splitAF('', 12); // Promise that resolves to ['s', 'p', 'l', 'i', 't', 't', 'e', 'd']\n * AsyncAF(str).splitAF('', 0); // Promise that resolves to []\n *\n * @since 5.1.0\n * @see split (alias)\n * @memberof AsyncAF#\n */\nconst splitAF = function (separator = undefined, limit = undefined) {\n  return this.then(str => {\n    if (typeof str !== 'string' || Array.isArray(str))\n      throw TypeError(`splitAF may be called on a string but was called on ${str}`);\n    return String.prototype.split.call(str, separator, limit);\n  });\n};\n\nexport default splitAF;\n","import createNewlessClass from '../methods/_internal/createNewlessClass';\nimport {AsyncAfWrapperProto as AsyncAfProto} from './AsyncAfWrapper';\nimport {staticMethods, prototypeMethods} from '../../packageList';\n\n/**\n * class that holds all the AsyncAF methods\n *\n * while AsyncAF is a class, it can create instances with or without the `new` keyword\n * @param {any} data the data to be wrapped by the AsyncAF class; can be promises or non-promises\n * @returns {Object} returns an instance of AsyncAF wrapping the passed in data\n * @example\n *\n * const promises = [1, 2, 3].map(n => Promise.resolve(n));\n *\n *\n * AsyncAF(promises).mapAF(n => n * 2).filterAF(n => n !== 4).forEachAF(n => console.log(n));\n * // logs 2 then 6\n * @since 3.0.0\n * @see AsyncAfWrapper\n * @class AsyncAF\n */\nconst AsyncAF = createNewlessClass(\n  class AsyncAF extends AsyncAfProto {},\n);\n\nconst prepForDefine = methods => methods.reduce((methods, method) => {\n  // add all '*AF' methods and add 'AF-less' aliases (e.g., mapAF -> map)\n  const [alias] = method.name.split`AF` || /* istanbul ignore next */ [method.name];\n  return Object.assign(\n    methods, {[method.name]: {value: method}}, {[alias]: {value: method}},\n  );\n}, {});\n\nObject.defineProperties(AsyncAfProto, prepForDefine(staticMethods));\nObject.defineProperties(AsyncAfProto.prototype, prepForDefine(prototypeMethods));\n\nexport default AsyncAF;\n"],"names":["nameFunction","fn","name","Object","defineProperty","value","configurable","createNewlessClass","Class","Newless","args","prototype","setPrototypeOf","constructor","nameFn","inSeries","WeakMap","series","get","this","set","io","dataStore","AsyncAfWrapperProto","data","Promise","resolve","then","reject","catch","finally","onFinally","use","prototypeMethods","staticMethods","TypeError","assign","defineProperties","Symbol","toStringTag","logAF","items","label","unshift","setFormat","labelFormat","start","Date","now","all","toLog","duration","numberOf","toFixed","push","wrappedLog","console","log","writable","wrappedWarn","warn","error","Error","stack","targetLine","split","filter","_","i","lines","test","fullPath","slice","indexOf","replace","target","lastIndexOf","formats","file","path","parent","arrow","format","line","col","pop","join","custom","options","reset","permissiveIsArrayLike","obj","Array","isArray","length","promiseAllWithHoles","promises","result","pending","settlePromise","serial","arr","resolveSerially","resolved","hole","el","parallel","mapper","thisArg","undefined","map","call","joinAF","separator","resolveByType","makeScoped","toLowerCase","method","arrayMethods","callback","reduce","expr","bools","arguments","acc","reduceAF","seriesEveryAF","bool","every","Boolean","seriesSomeAF","some","searchItem","fromIndex","arrOrStr","fromIdx","includes","seriesIncludesAF","a","b","Number","isNaN","sameValueZero","Math","max","abs","filled","from","seriesFindAF","seriesFindIndexAF","seriesIndexOfAF","len","seriesLastIndexOfAF","min","values","isThenable","thenable","concat","stringMethods","limit","str","String","pluckMethods","packages","staticMethodsOnly","prototypeMethodsOnly","AsyncAF","AsyncAfProto","prepForDefine","methods","alias"],"mappings":"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"}