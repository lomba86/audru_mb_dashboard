/*!
 * async-af v7.0.39
 * 
 * AsyncAF (The asynciest of async libs there ever was or ever will be...AsyncAF!?) 
 * (https://async-af.js.org/AsyncAF)
 * 
 * Copyright (c) 2017-present, Scott Rudiger (https://github.com/ScottRudiger)
 * 
 * This source code is licensed under the MIT license found in this library's
 * GitHub repository (https://github.com/AsyncAF/AsyncAF/blob/master/LICENSE).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("AsyncAF", [], factory);
	else if(typeof exports === 'object')
		exports["AsyncAF"] = factory();
	else
		root["AsyncAF"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./lib/classes/AsyncAF.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./lib/classes/AsyncAF.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./lib/methods/_internal/createNewlessClass.js
var createNewlessClass = __webpack_require__("./lib/methods/_internal/createNewlessClass.js");

// EXTERNAL MODULE: ./lib/classes/AsyncAfWrapper.js + 2 modules
var AsyncAfWrapper = __webpack_require__("./lib/classes/AsyncAfWrapper.js");

// EXTERNAL MODULE: ./lib/methods/_internal/nameFunction.js
var nameFunction = __webpack_require__("./lib/methods/_internal/nameFunction.js");

// EXTERNAL MODULE: ./lib/methods/other/logAF.js + 4 modules
var logAF = __webpack_require__("./lib/methods/other/logAF.js");

// EXTERNAL MODULE: ./lib/methods/arrays/mapAF.js
var mapAF = __webpack_require__("./lib/methods/arrays/mapAF.js");

// EXTERNAL MODULE: ./lib/methods/arrays/forEachAF.js
var forEachAF = __webpack_require__("./lib/methods/arrays/forEachAF.js");

// EXTERNAL MODULE: ./lib/methods/arrays/filterAF.js
var filterAF = __webpack_require__("./lib/methods/arrays/filterAF.js");

// EXTERNAL MODULE: ./lib/methods/arrays/reduceAF.js + 1 modules
var reduceAF = __webpack_require__("./lib/methods/arrays/reduceAF.js");

// EXTERNAL MODULE: ./lib/methods/arrays/everyAF.js
var everyAF = __webpack_require__("./lib/methods/arrays/everyAF.js");

// EXTERNAL MODULE: ./lib/methods/arrays/someAF.js
var someAF = __webpack_require__("./lib/methods/arrays/someAF.js");

// EXTERNAL MODULE: ./lib/methods/arrays/includesAF.js
var includesAF = __webpack_require__("./lib/methods/arrays/includesAF.js");

// EXTERNAL MODULE: ./lib/methods/arrays/findAF.js
var findAF = __webpack_require__("./lib/methods/arrays/findAF.js");

// EXTERNAL MODULE: ./lib/methods/arrays/findIndexAF.js
var findIndexAF = __webpack_require__("./lib/methods/arrays/findIndexAF.js");

// EXTERNAL MODULE: ./lib/methods/arrays/indexOfAF.js
var indexOfAF = __webpack_require__("./lib/methods/arrays/indexOfAF.js");

// EXTERNAL MODULE: ./lib/methods/arrays/lastIndexOfAF.js
var lastIndexOfAF = __webpack_require__("./lib/methods/arrays/lastIndexOfAF.js");

// EXTERNAL MODULE: ./lib/methods/arrays/joinAF.js
var joinAF = __webpack_require__("./lib/methods/arrays/joinAF.js");

// EXTERNAL MODULE: ./lib/methods/arrays/concatAF.js
var concatAF = __webpack_require__("./lib/methods/arrays/concatAF.js");

// EXTERNAL MODULE: ./lib/methods/strings/splitAF.js
var splitAF = __webpack_require__("./lib/methods/strings/splitAF.js");

// CONCATENATED MODULE: ./packageList.js

/* eslint-disable import/first */

const libName = 'async-af';
const libPath = './lib/';

const makeScoped = name => "@".concat(libName, "/").concat(name.replace(/AsyncAf|AF/g, '').toLowerCase());
/* ____________________________
  |           CLASSES          |
  |____________________________| */


const classPath = "".concat(libPath, "classes/");
const classes = [[{
  name: 'AsyncAF'
}, "".concat(classPath, "AsyncAF"), libName], [{
  name: 'AsyncAfWrapper'
}, "".concat(classPath, "AsyncAfWrapper"), makeScoped('AsyncAfWrapper')]];
/* ____________________________
  |       STATIC METHODS       |
  |____________________________| */


const staticMethods = [Object(nameFunction["default"])(logAF["default"], 'logAF')].map(method => [method, "".concat(libPath, "methods/other/").concat(method.name), makeScoped(method.name)]);
/* ____________________________
  |      PROTOTYPE METHODS     |
  |____________________________| */
// Arrays














const arrayMethods = [Object(nameFunction["default"])(mapAF["default"], 'mapAF'), Object(nameFunction["default"])(forEachAF["default"], 'forEachAF'), Object(nameFunction["default"])(filterAF["default"], 'filterAF'), Object(nameFunction["default"])(reduceAF["default"], 'reduceAF'), Object(nameFunction["default"])(everyAF["default"], 'everyAF'), Object(nameFunction["default"])(someAF["default"], 'someAF'), Object(nameFunction["default"])(includesAF["default"], 'includesAF'), Object(nameFunction["default"])(findAF["default"], 'findAF'), Object(nameFunction["default"])(findIndexAF["default"], 'findIndexAF'), Object(nameFunction["default"])(indexOfAF["default"], 'indexOfAF'), Object(nameFunction["default"])(lastIndexOfAF["default"], 'lastIndexOfAF'), Object(nameFunction["default"])(joinAF["default"], 'joinAF'), Object(nameFunction["default"])(concatAF["default"], 'concatAF')].map(method => [method, "".concat(libPath, "methods/arrays/").concat(method.name), makeScoped(method.name)]); // strings


const stringMethods = [Object(nameFunction["default"])(splitAF["default"], 'splitAF')].map(method => [method, "".concat(libPath, "methods/strings/").concat(method.name), makeScoped(method.name)]);
const prototypeMethods = [...arrayMethods, ...stringMethods];
/* ____________________________
  |         COLLECTIONS        |
  |____________________________| */
// import arrays from './lib/collections/arrays';

const collections = [// arrays,
];
/* harmony default export */ var packageList = ([...classes, ...staticMethods, ...prototypeMethods, ...collections]);

const pluckMethods = packages => packages.map((_ref) => {
  let [method] = _ref;
  return method;
});

const staticMethodsOnly = pluckMethods(staticMethods);
const prototypeMethodsOnly = pluckMethods(prototypeMethods);

// CONCATENATED MODULE: ./lib/classes/AsyncAF.js
function _templateObject() {
  const data = _taggedTemplateLiteral(["AF"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }




/**
 * class that holds all the AsyncAF methods
 *
 * while AsyncAF is a class, it can create instances with or without the `new` keyword
 * @param {any} data the data to be wrapped by the AsyncAF class; can be promises or non-promises
 * @returns {Object} returns an instance of AsyncAF wrapping the passed in data
 * @example
 *
 * const promises = [1, 2, 3].map(n => Promise.resolve(n));
 *
 *
 * AsyncAF(promises).mapAF(n => n * 2).filterAF(n => n !== 4).forEachAF(n => console.log(n));
 * // logs 2 then 6
 * @since 3.0.0
 * @see AsyncAfWrapper
 * @class AsyncAF
 */

const AsyncAF_AsyncAF = Object(createNewlessClass["default"])(class AsyncAF extends AsyncAfWrapper["AsyncAfWrapperProto"] {});

const prepForDefine = methods => methods.reduce((methods, method) => {
  // add all '*AF' methods and add 'AF-less' aliases (e.g., mapAF -> map)
  const [alias] = method.name.split(_templateObject()) ||
  /* istanbul ignore next */
  [method.name];
  return Object.assign(methods, {
    [method.name]: {
      value: method
    }
  }, {
    [alias]: {
      value: method
    }
  });
}, {});

Object.defineProperties(AsyncAfWrapper["AsyncAfWrapperProto"], prepForDefine(staticMethodsOnly));
Object.defineProperties(AsyncAfWrapper["AsyncAfWrapperProto"].prototype, prepForDefine(prototypeMethodsOnly));
/* harmony default export */ var classes_AsyncAF = __webpack_exports__["default"] = (AsyncAF_AsyncAF);

/***/ }),

/***/ "./lib/classes/AsyncAfWrapper.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./lib/methods/_internal/createNewlessClass.js
var createNewlessClass = __webpack_require__("./lib/methods/_internal/createNewlessClass.js");

// CONCATENATED MODULE: ./lib/methods/other/use.js
/**
 * adds prototype/static methods to AsyncAF or AsyncAfWrapper
 *
 * see {@link AsyncAfWrapper AsyncAfWrapper} for an example of how to cherry-pick AsyncAF methods you'd like to use rather than pulling in the entire AsyncAF library;
 *
 * for something different, the following shows how to add custom methods to AsyncAF & AsyncAfWrapper
 *
 * **Example**
 *
 * say you want to extend AsyncAF with your own prototype method that acts on an array of numbers or promises that resolve to numbers and naively adds them up
 *
 * let's call it sumAF; here's some code:
 *
 * ```js
 * // sumAF.js
 *
 * const sumAF = function () {
 *   return this.then(nums => Promise.all(nums))
 *     .then(nums => nums.reduce((sum, num) => sum + num));
 * };
 *
 * export default sumAF;
 * ```
 *
 * pull in {@link AsyncAF AsyncAF} or {@link AsyncAfWrapper AsyncAfWrapper} and `sumAF` to the file you'd like to use it in:
 *
 * ```js
 * // otherFile.js
 *
 * import AsyncAF from 'async-af'; // or import AsyncAF from '@async-af/wrapper';
 * import sumAF from './sumAF';
 * ```
 *
 * then, call `use` on `AsyncAF` and pass in `sumAF` wrapped in an object to the first parameter, `prototypeMethods`:
 *
 * ```js
 * // otherFile.js
 * // ...
 *
 * AsyncAF.use({sumAF});
 * ```
 *
 * ready! now your custom prototype method will be available on AsyncAF
 *
 * ```js
 * // otherFile.js
 * // ...
 *
 * const promises = [1, 2, 3].map(n => Promise.resolve(n));
 *
 * const sum = AsyncAF(promises).sumAF()
 *
 * AsyncAF.logAF(sum);
 * // @otherFile.js:10:9:
 * //  6
 * // in 0.001 secs
 * ```
 *
 * if you'd like to add a static method to AsyncAF, `use` accepts a second optional argument `staticMethods`; for example:
 *
 * ```js
 * const staticNoop = () => {};
 *
 * AsyncAF.use({}, {staticNoop});
 *
 * AsyncAF.staticNoop(); // noop
 * ```
 *
 * @static
 * @param {Object} prototypeMethods an Object containing the prototype methods you'd like to use
 * @param {Object=} staticMethods an Object containing the static methods you'd like to use
 * @returns {undefined} adds prototype/static methods to AsyncAF or AsyncAfWrapper
 * @since 3.0.0
 * @see AsyncAF
 * @see AsyncAfWrapper
 * @see {@tutorial TOO_MANY_IMPORTS}
 * @memberof AsyncAfWrapper
 * @alias AsyncAfWrapper#use
 */
const use = function use(prototypeMethods) {
  let staticMethods = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (typeof prototypeMethods !== 'object') throw TypeError('prototypeMethods param accepts an Object containing the prototypeMethods you\'d like to add to the AsyncAF prototype, or an empty Object');
  if (typeof staticMethods !== 'object') throw TypeError('staticMethods param accepts an Object containing the staticMethods you\'d like to add to AsyncAF');
  Object.assign(this.prototype, prototypeMethods);
  Object.assign(this, staticMethods);
};

/* harmony default export */ var other_use = (use);
// CONCATENATED MODULE: ./lib/methods/other/series.js
const inSeries = new WeakMap();
const series = {
  inSeries: {
    get() {
      return inSeries.get(this);
    }

  },

  /**
   * indicates that the next method invoked should be performed in series
   *
   * when you need to perform a method in series rather than in parallel, prepend the method with `series`; e.g.:
   * ```js
   * AsyncAF(promises).series.forEachAF(callback)
   * ```
   *
   * `series` can currently be chained with:
   * - {@link AsyncAF#everyAF everyAF}
   * - {@link AsyncAF#filterAF filterAF}
   * - {@link AsyncAF#findAF findAF}
   * - {@link AsyncAF#findIndexAF findIndexAF}
   * - {@link AsyncAF#forEachAF forEachAF}
   * - {@link AsyncAF#includesAF includesAF}
   * - {@link AsyncAF#indexOfAF indexOfAF}
   * - {@link AsyncAF#lastIndexOfAF lastIndexOfAF}
   * - {@link AsyncAF#mapAF mapAF}
   * - {@link AsyncAF#reduceAF reduceAF}
   * - {@link AsyncAF#someAF someAF}
   *
   * @example
   * import delay from 'delay'; // {@link https://www.npmjs.com/package/delay}
   *
   * const nums = [2, 1];
   *
   * // perform a serial forEach by chaining {@link AsyncAF#series series} and {@link AsyncAF#forEachAF forEachAF}
   * (async () => {
   *   const start = Date.now();
   *
   *   await AsyncAF(nums).series.forEachAF(async num => {
   *     await delay(num * 1000);
   *     console.log(num, `at ~${Date.now() - start} ms`);
   *   });
   *
   *   console.log(`total: ~${Date.now() - start} ms`);
   * })();
   *
   * // logs:
   * // 2  'at ~2000 ms'
   * // 1  'at ~3000 ms'
   * // total: ~3000 ms
   *
   *
   * // perform a parallel forEach by omitting {@link AsyncAF#series series}
   * (async () => {
   *   const start = Date.now();
   *
   *   await AsyncAF(nums).forEachAF(async num => {
   *     await delay(num * 1000);
   *     console.log(num, `at ~${Date.now() - start} ms`);
   *   });
   *
   *   console.log(`total: ~${Date.now() - start} ms`);
   * })();
   *
   * // logs:
   * // 1  'at ~1000 ms'
   * // 2  'at ~2000 ms'
   * // total: ~2000 ms
   *
   * @function series
   * @returns {AsyncAF.<any>} returns an instance of AsyncAF that will perform the next method invocation serially
   * @since 7.0.0
   * @see {@link AsyncAF#io io} (alias)
   * @memberof AsyncAF#
   */
  series: {
    get() {
      inSeries.set(this, !this.inSeries);
      return this;
    }

  },

  /**
   * `io` (in order) indicates that the next method invoked should be performed in series
   *
   * when you need to perform a method in series rather than in parallel, prepend the method with `io`; e.g.:
   * ```js
   * AsyncAF(promises).io.forEachAF(callback)
   * ```
   *
   * `io` is an alias for `series`; see {@link AsyncAF#series series's documentation} for more
   * @function io
   * @returns {AsyncAF.<any>} returns an instance of AsyncAF that will perform the next method invocation serially
   * @since 7.0.0
   * @see {@link AsyncAF#series series} (alias)
   * @memberof AsyncAF#
   */
  io: {
    get() {
      return this.series;
    }

  }
};
/* harmony default export */ var other_series = (series);
// CONCATENATED MODULE: ./lib/classes/AsyncAfWrapper.js
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AsyncAfWrapperProto", function() { return AsyncAfWrapperProto; });
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




const dataStore = new WeakMap();

class AsyncAfWrapperProto {
  constructor(data) {
    dataStore.set(this, Promise.resolve(data));
  }

  then(resolve, reject) {
    return this.constructor(dataStore.get(this).then(resolve, reject));
  }

  catch(reject) {
    return this.then(null, reject);
  }

  finally(onFinally) {
    return dataStore.get(this).finally(onFinally);
  }

}

AsyncAfWrapperProto.use = other_use;
Object.defineProperties(AsyncAfWrapperProto.prototype, _objectSpread({}, other_series, {
  [Symbol.toStringTag]: {
    value: 'AsyncAF'
  }
}));
/**
 * empty AsyncAF class wrapper
 *
 * AsyncAfWrapper is one option for cherry-picking only the methods you'd like to use in your code; {@link AsyncAfWrapper#use use}, {@link AsyncAF#series series}, and {@link AsyncAF#io io} are the only methods initially available on AsyncAfWrapper; see example below
 *
 * **Note:** while AsyncAfWrapper is a class, it can create instances with or without the `new` keyword
 *
 * **Example**
 *
 * say you only want to use {@link AsyncAF#mapAF mapAF}, {@link AsyncAF#filterAF filterAF}, {@link AsyncAF#forEachAF forEachAF}, and {@link AsyncAF#logAF logAF} instead of pulling in the entire AsyncAF library
 *
 * first, install the separate packages (e.g., for npm):
 *
 * `$ npm install --save @async-af/{wrapper,map,filter,foreach,log}`
 *
 * or, if on Windows:
 *
 * `$ npm install --save @async-af/wrapper @async-af/map @async-af/filter @async-af/foreach @async-af/log`
 *
 * then import the packages
 * ```js
 * import AsyncAF from '@async-af/wrapper'; // aliasing 'AsyncAfWrapper' as 'AsyncAF'
 * import mapAF from '@async-af/map';
 * import filterAF from '@async-af/filter';
 * import forEachAF from '@async-af/foreach';
 * import logAF from '@async-af/log';
 * ```
 *
 * _if you'd like to save some vertical screen real estate and cut the imports down to one line, see_ {@tutorial TOO_MANY_IMPORTS}
 *
 * then call {@link AsyncAfWrapper#use use}, including all prototype methods you'd like to add to AsyncAfWrapper's prototype in the first argument, `prototypeMethods` and all static methods you'd like to add to AsyncAfWrapper in the second optional argument, `staticMethods`
 * ```js
 * AsyncAF.use({ // prototype methods go in the first argument
 *   mapAF,
 *   filterAF,
 *   forEachAF
 * }, { // static methods go in the second argument
 *   logAF
 * });
 * ```
 *
 * ready to go!
 * ```js
 * const promises = [1, 2, 3].map(n => Promise.resolve(n));
 *
 * AsyncAF(promises).mapAF(n => n * 2).filterAF(n => n !== 4).forEachAF(n => console.log(n));
 * // logs 2 then 6
 *
 * AsyncAF.logAF(promises);
 * // @filename.js:24:9:
 * //  [ 1, 2, 3 ]
 * // in 0.003 secs
 * ```
 *
 * **protip:** you can use the same technique to add your own custom prototype or static methods to AsyncAfWrapper or even to the main AsyncAF class; see {@link AsyncAfWrapper#use use} for an example
 * @param {any} data the data to be wrapped by the AsyncAF class; can be promises or non-promises
 * @returns {Object} returns an instance of AsyncAfWrapper wrapping the passed in data
 * @since 3.0.0
 * @see AsyncAF
 * @see {@link AsyncAfWrapper#use use}
 * @see {@tutorial TOO_MANY_IMPORTS}
 * @class AsyncAfWrapper
 */

const AsyncAfWrapper = Object(createNewlessClass["default"])(class AsyncAfWrapper extends AsyncAfWrapperProto {});

/* harmony default export */ var classes_AsyncAfWrapper = __webpack_exports__["default"] = (AsyncAfWrapper);

/***/ }),

/***/ "./lib/methods/_internal/commonCallback.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* eslint-disable no-unused-vars, valid-jsdoc */

/**
 * @typedef {callback} _
 * @param {?} currentValue
 * @param {Number=} index
 * @param {[]=} array
 * @returns {any}
 */
function callback(currentValue, index, array) {}

/* harmony default export */ __webpack_exports__["default"] = (callback);

/***/ }),

/***/ "./lib/methods/_internal/createNewlessClass.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _nameFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./lib/methods/_internal/nameFunction.js");


const createNewlessClass = Class => {
  const {
    name
  } = Class;

  const Newless = function Newless() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return new Class(...args);
  };

  Newless.prototype = Class.prototype;
  Object.setPrototypeOf(Newless, Class);
  Newless.prototype.constructor = Newless;
  return Object(_nameFunction__WEBPACK_IMPORTED_MODULE_0__["default"])(Newless, name);
};

/* harmony default export */ __webpack_exports__["default"] = (createNewlessClass);

/***/ }),

/***/ "./lib/methods/_internal/nameFunction.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
const nameFunction = function nameFunction(fn, name) {
  return Object.defineProperty(fn, 'name', {
    value: name,
    configurable: true
  });
};

/* harmony default export */ __webpack_exports__["default"] = (nameFunction);

/***/ }),

/***/ "./lib/methods/_internal/permissiveIsArrayLike.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
const permissiveIsArrayLike = function permissiveIsArrayLike(obj) {
  return Array.isArray(obj) || obj != null && obj.length != null;
};

/* harmony default export */ __webpack_exports__["default"] = (permissiveIsArrayLike);

/***/ }),

/***/ "./lib/methods/_internal/promiseAllWithHoles.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
const promiseAllWithHoles = promises => new Promise((resolve, reject) => {
  const length = promises.length >>> 0;
  const result = Array(length);
  let pending = length;
  let i = length;
  if (!length) return resolve(result);

  const settlePromise = i => Promise.resolve(promises[i]).then(value => {
    if (i in promises) result[i] = value;
    if (! --pending) resolve(result);
  }, reject);

  while (i--) settlePromise(i);
});

/* harmony default export */ __webpack_exports__["default"] = (promiseAllWithHoles);

/***/ }),

/***/ "./lib/methods/_internal/resolve.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "serial", function() { return serial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parallel", function() { return parallel; });
/* harmony import */ var _promiseAllWithHoles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./lib/methods/_internal/promiseAllWithHoles.js");


const serial = arr => function resolveSerially(resolved, i) {
  const {
    length
  } = resolved;
  if (!length) return Promise.resolve(resolved);
  const hole = !(i in arr);
  return Promise.resolve(arr[i]).then(el => {
    if (!hole) resolved[i] = el;
    if (i === length - 1) return resolved;
    return resolveSerially(resolved, i + 1);
  });
}(Array(arr.length >>> 0), 0);

const parallel = function parallel(arr, mapper) {
  let thisArg = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
  return Object(_promiseAllWithHoles__WEBPACK_IMPORTED_MODULE_0__["default"])(arr, el => el).then(!mapper ? undefined : arr => Object(_promiseAllWithHoles__WEBPACK_IMPORTED_MODULE_0__["default"])(Array.prototype.map.call(arr, mapper, thisArg)));
};



/***/ }),

/***/ "./lib/methods/arrays/concatAF.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
const resolveByType = data => Promise[Array.isArray(data) ? 'all' : 'resolve'](data);
/**
 * merges an array or string with one or more arrays, strings, or other values, and resolves to a new array or string;
 *
 * concatAF flexibly accepts arrays, strings, promises, other values, or other instances of AsyncAF; see examples
 *
 * @param {any} values arrays, strings, or values to concatenate into a new array or string
 *  - if any values are a Promise, they'll first be resolved then concatenated
 *  - if any values are an instance of AsyncAF, they'll be merged into one instance
 * @returns {Promise.<Array>|Promise.<String>} `Promise` that resolves to a newly merged array or string
 * @example
 *
 * // arrays
 * const arr = Promise.resolve([1, 2]);
 * AsyncAF(arr).concatAF([3, 4]); // Promise that resolves to [1, 2, 3, 4]
 * AsyncAF(arr).concatAF([3, 4], [5, 6]); // Promise that resolves to [1, 2, 3, 4, 5, 6]
 *
 * // nested arrays
 * const arr1 = Promise.resolve([1, 2]);
 * const arr2 = [3, [4, 5]];
 * AsyncAF(arr1).concatAF(arr2); // Promise that resolves to [1, 2, 3, [4, 5]]
 *
 * // strings
 * const str = Promise.resolve('str');
 * AsyncAF(str).concatAF('ing'); // Promise that resolves to 'string'
 * AsyncAF(str).concatAF('ing', 'y'); // Promise that resolves to 'stringy'
 *
 * // other instances of AsyncAF
 * const aaf1 = AsyncAF([1, 2]);
 * const aaf2 = AsyncAF(3);
 *
 * aaf1.concatAF(aaf2); // Promise that resolves to [1, 2, 3];
 *
 * const aaf3 = AsyncAF('stringy');
 * const aaf4 = AsyncAF('AF');
 *
 * aaf3.concatAF(aaf4); // Promise that resolves to 'stringyAF'
 *
 * // promises
 * const [p1, p2, p3] = [[1, 2], 3, [4, [5, 6]]].map(v => Promise.resolve(v));
 *
 * AsyncAF(p1).concatAF(p2); // Promise that resolves to [1, 2, 3]
 * AsyncAF(p1).concatAF(p2, p3) // Promise that resolves to [1, 2, 3, 4, [5, 6]]
 *
 * const pStr1 = Promise.resolve('str');
 * const pStr2 = Promise.resolve('ing');
 * const pStr3 = Promise.resolve('y');
 *
 * AsyncAF(pStr1).concatAF(pStr2); // Promise that resolves to 'string'
 * AsyncAF(pStr1).concatAF(pStr2, pStr3); // Promise that resolves to 'stringy'
 *
 * // Note: concatAF will not resolve deeply nested promises; if you need this behavior, concatAF can be used in a
 * // function; for example, this function recursively flattens an array of promises
 *
 * const flattenAsync = arr => AsyncAF(arr).reduceAF(async (acc, val) => {
 *   return Array.isArray(await val)
 *     ? AsyncAF(acc).concatAF(flattenAsync(val))
 *     : AsyncAF(acc).concatAF(val), []);
 * };
 *
 * @since 5.3.0
 * @see concat (alias)
 * @memberof AsyncAF#
 */


const concatAF = function concatAF() {
  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
    values[_key] = arguments[_key];
  }

  const isThenable = value => [Promise, this.constructor].some(thenable => value instanceof thenable);

  const concat = (arrOrStr, value) => isThenable(value) && value.then(resolveByType).then(value => arrOrStr.concat(value)) || arrOrStr.concat(value);

  return this.then(arrOrStr => {
    if (!(typeof arrOrStr === 'string' || Array.isArray(arrOrStr))) throw TypeError("concatAF cannot be called on ".concat(arrOrStr, ", only on an Array or String"));
    return resolveByType(arrOrStr).then(arrOrStr => values.reduce((arrOrStr, value) => isThenable(arrOrStr) ? arrOrStr.then(arrOrStr => concat(arrOrStr, value)) : concat(arrOrStr, value), arrOrStr));
  });
};

/* harmony default export */ __webpack_exports__["default"] = (concatAF);

/***/ }),

/***/ "./lib/methods/arrays/everyAF.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_commonCallback__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./lib/methods/_internal/commonCallback.js");
/* harmony import */ var _internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./lib/methods/_internal/permissiveIsArrayLike.js");
/* harmony import */ var _internal_resolve__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./lib/methods/_internal/resolve.js");
 // eslint-disable-line no-unused-vars



/**
 * tests whether all elements in the array pass the test implemented by the provided callback function
 *
 * if any elements are a `Promise`, they will first be resolved in parallel and then tested
 *
 * *Note*: since `everyAF` is run in parallel, `callback` will be run on all elements even if one of the first few elements fails the test; if this behavior is not desireable, consider using `series.everyAF` or its alias, `io.everyAF`
 *
 * @param {callback} callback function that tests each element of the array
 *
 * `callback` accepts three arguments:
 * - `currentValue` value of the current element being processed in the array
 * - `index`*`(optional)`* index of `currentValue` in the array
 * - `array`*`(optional)`* the array that `everyAF` is being applied to
 * @param {Object=} thisArg value to use as `this` when executing `callback`
 * @returns {Promise.<Boolean>} `Promise` that resolves to `true` if the callback function returns a truthy value for every array element; otherwise, `false`
 * @example
 *
 * const promises = [1, 2, 3].map(n => Promise.resolve(n));
 *
 *
 * // basic usage
 * const allAreOdd = AsyncAF(promises).everyAF(n => n % 2);
 *
 * console.log(allAreOdd); // Promise that resolves to false
 *
 * AsyncAF.logAF(allAreOdd); // logs false
 *
 *
 * // using .then
 * AsyncAF(promises).everyAF(n => n % 2).then(allAreOdd => {
 *   console.log(allAreOdd); // logs false
 * });
 *
 *
 * // inside an async function
 * (async () => {
 *   const allAreNums = await AsyncAF(promises).everyAF(
 *     n => typeof n === 'number'
 *   );
 *   console.log(allAreNums); // logs true
 * })();
 * @since 3.2.0
 * @see every (alias)
 * @see {@link AsyncAF#series series.everyAF}
 * @memberof AsyncAF#
 */

const everyAF = function everyAF(callback) {
  let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  return this.then(arr => {
    if (!Object(_internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_1__["default"])(arr)) throw TypeError("everyAF cannot be called on ".concat(arr, ", only on an Array or array-like Object"));
    if (typeof callback !== 'function') throw TypeError("".concat(callback, " is not a function"));
    const length = arr.length >>> 0;
    return this.inSeries ? !length && true || function seriesEveryAF(arr, i) {
      const hole = !(i in arr);
      return Promise.resolve(arr[i]).then(el => {
        arr[i] = el;
        return Promise.resolve(!hole && callback.call(thisArg, el, i, arr)).then(bool => {
          if (!bool && !hole) return false;
          if (i === length - 1) return true;
          return seriesEveryAF(arr, i + 1);
        });
      });
    }(Array.prototype.slice.call(arr), 0) : Object(_internal_resolve__WEBPACK_IMPORTED_MODULE_2__["parallel"])(arr, callback, thisArg).then(bools => bools.every(Boolean));
  });
};

/* harmony default export */ __webpack_exports__["default"] = (everyAF);

/***/ }),

/***/ "./lib/methods/arrays/filterAF.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_commonCallback__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./lib/methods/_internal/commonCallback.js");
/* harmony import */ var _internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./lib/methods/_internal/permissiveIsArrayLike.js");
/* harmony import */ var _internal_resolve__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./lib/methods/_internal/resolve.js");
 // eslint-disable-line no-unused-vars



/**
 * creates a new `Array` with all elements that pass the test implemented by the provided callback function
 *
 * if any elements are a `Promise`, they will first be resolved in parallel and then tested
 *
 * *Note*: if you'd rather resolve and test elements in series, consider using `series.filterAF` or its alias, `io.filterAF`
 *
 * @param {callback} callback function that tests each element of the array; return `true` to keep the element, `false` to filter it out
 *
 * `callback` accepts three arguments:
 * - `currentValue` value of the current element being processed in the array
 * - `index`*`(optional)`* index of `currentValue` in the array
 * - `array`*`(optional)`* the array that `filterAF` is being applied to
 * @param {Object=} thisArg value to use as `this` when executing `callback`
 * @returns {Promise.<Array>} `Promise` that resolves to a new `Array` with the elements that pass the test; if no elements pass the test, the promise will resolve to an empty array
 * @example
 *
 * const promises = [1, 2, 3].map(n => Promise.resolve(n));
 *
 *
 * // basic usage
 * const odds = AsyncAF(promises).filterAF(n => n % 2);
 *
 * console.log(odds); // Promise that resolves to [1, 3]
 *
 * AsyncAF.logAF(odds); // logs [1, 3]
 *
 *
 * // using .then
 * AsyncAF(promises).filterAF(n => n % 2).then(odds => {
 *   console.log(odds); // logs [1, 3]
 * });
 *
 *
 * // inside an async function
 * (async () => {
 *   const odds = await AsyncAF(promises).filterAF(
 *     n => n % 2
 *   );
 *   console.log(odds); // logs [1, 3]
 * })();
 * @since 3.0.0
 * @see filter (alias)
 * @see {@link AsyncAF#series series.filterAF}
 * @memberof AsyncAF#
 */

const filterAF = function filterAF(callback) {
  let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  return this.then(arr => {
    if (!Object(_internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_1__["default"])(arr)) throw TypeError("filterAF cannot be called on ".concat(arr, ", only on an Array or array-like Object"));
    if (typeof callback !== 'function') throw TypeError("".concat(callback, " is not a function"));
    return (this.inSeries ? _internal_resolve__WEBPACK_IMPORTED_MODULE_2__["serial"] : _internal_resolve__WEBPACK_IMPORTED_MODULE_2__["parallel"])(arr).then(arr => (this.inSeries ? arr.reduce((bools, el, i, arr) => bools.then(bools => {
      bools[i] = callback.call(thisArg, el, i, arr);
      return Promise.all(bools);
    }), Promise.all([])) : Object(_internal_resolve__WEBPACK_IMPORTED_MODULE_2__["parallel"])(arr, callback, thisArg)).then(bools => arr.filter((_, i) => bools[i])));
  });
};

/* harmony default export */ __webpack_exports__["default"] = (filterAF);

/***/ }),

/***/ "./lib/methods/arrays/findAF.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_commonCallback__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./lib/methods/_internal/commonCallback.js");
/* harmony import */ var _internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./lib/methods/_internal/permissiveIsArrayLike.js");
/* harmony import */ var _internal_resolve__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./lib/methods/_internal/resolve.js");
 // eslint-disable-line no-unused-vars



/**
 * resolves to the value of the first element in the array that satisfies the provided callback function; otherwise, `undefined`
 *
 * *Note*: since `findAF` is run in parallel, `callback` will be run on all elements even if one of the first few elements passes the test; if this behavior is not desireable, consider using `series.findAF` or its alias, `io.findAF`
 *
 * @param {callback} callback function to test each element in the array
 *
 * `callback` accepts three arguments:
 * - `currentValue` value of the current element being processed in the array
 * - `index`*`(optional)`* index of `currentValue` in the array
 * - `array`*`(optional)`* the array that findAF is being applied to
 * @param {Object=} thisArg value to use as `this` when executing `callback`
 * @returns {Promise.<any>} `Promise` that resolves to the first element in the array that passes the test; otherwise, undefined
 * @example
 *
 * const inventory = [
 *  {name: 'nuts', quantity: 2000},
 *  {name: 'bolts', quantity: 5000},
 *  {name: 'screws', quantity: 9001}
 * ].map(part => Promise.resolve(part));
 *
 * AsyncAF(inventory).findAF(part => part.name === 'screws');
 * // Promise that resolves to {name: 'screws', quantity: 9001}
 * @since 3.5.0
 * @see find (alias)
 * @see {@link AsyncAF#series series.findAF}
 * @memberof AsyncAF#
 */

const findAF = function findAF(callback) {
  let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  return this.then(arr => {
    if (!Object(_internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_1__["default"])(arr)) throw TypeError("findAF cannot be called on ".concat(arr, ", only on an Array or array-like Object"));
    if (typeof callback !== 'function') throw TypeError("".concat(callback, " is not a function"));
    const filled = Array.from(arr);
    const length = filled.length >>> 0;
    return this.inSeries ? (length || undefined) && function seriesFindAF(arr, i) {
      return Promise.resolve(arr[i]).then(el => {
        arr[i] = el;
        return Promise.resolve(callback.call(thisArg, el, i, arr)).then(bool => {
          if (bool) return el;
          if (i === length - 1) return;
          return seriesFindAF(arr, i + 1);
        });
      });
    }(filled, 0) : Object(_internal_resolve__WEBPACK_IMPORTED_MODULE_2__["parallel"])(filled, callback, thisArg).then(bools => arr[bools.indexOf(true)]);
  });
};

/* harmony default export */ __webpack_exports__["default"] = (findAF);

/***/ }),

/***/ "./lib/methods/arrays/findIndexAF.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_commonCallback__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./lib/methods/_internal/commonCallback.js");
/* harmony import */ var _internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./lib/methods/_internal/permissiveIsArrayLike.js");
/* harmony import */ var _internal_resolve__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./lib/methods/_internal/resolve.js");
 // eslint-disable-line no-unused-vars



/**
 * resolves to the index of the first element in the array that satisfies the provided callback function; otherwise, `-1`
 *
 * *Note*: since `findIndexAF` is run in parallel, `callback` will be run on all indices even if one of the first few indices passes the test; if this behavior is not desireable, consider using `series.findIndexAF` or its alias, `io.findIndexAF`
 *
 * @param {callback} callback function to test each element in the array
 *
 * `callback` accepts three arguments:
 * - `currentValue` value of the current element being processed in the array
 * - `index`*`(optional)`* index of `currentValue` in the array
 * - `array`*`(optional)`* the array that findIndexAF is being applied to
 * @param {Object=} thisArg value to use as `this` when executing `callback`
 * @returns {Promise.<Number>} `Promise` that resolves to the index of the first element in the array that passes the test; otherwise, `-1`
 * @example
 *
 * const inventory = [
 *  {name: 'nuts', quantity: 2000},
 *  {name: 'bolts', quantity: 5000},
 *  {name: 'screws', quantity: 9001}
 * ].map(part => Promise.resolve(part));
 *
 * AsyncAF(inventory).findIndexAF(part => part.name === 'screws');
 * // Promise that resolves to 2
 * @since 3.5.0
 * @see findIndex (alias)
 * @see {@link AsyncAF#series series.findIndexAF}
 * @memberof AsyncAF#
 */

const findIndexAF = function findIndexAF(callback) {
  let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  return this.then(arr => {
    if (!Object(_internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_1__["default"])(arr)) throw TypeError("findIndexAF cannot be called on ".concat(arr, ", only on an Array or array-like Object"));
    if (typeof callback !== 'function') throw TypeError("".concat(callback, " is not a function"));
    const filled = Array.from(arr);
    const length = filled.length >>> 0;
    return this.inSeries ? !length && -1 || function seriesFindIndexAF(arr, i) {
      return Promise.resolve(arr[i]).then(el => {
        arr[i] = el;
        return Promise.resolve(callback.call(thisArg, el, i, arr)).then(bool => {
          if (bool) return i;
          if (i === length - 1) return -1;
          return seriesFindIndexAF(arr, i + 1);
        });
      });
    }(filled, 0) : Object(_internal_resolve__WEBPACK_IMPORTED_MODULE_2__["parallel"])(filled, callback, thisArg).then(bools => bools.indexOf(true));
  });
};

/* harmony default export */ __webpack_exports__["default"] = (findIndexAF);

/***/ }),

/***/ "./lib/methods/arrays/forEachAF.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_commonCallback__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./lib/methods/_internal/commonCallback.js");
/* harmony import */ var _internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./lib/methods/_internal/permissiveIsArrayLike.js");
/* harmony import */ var _internal_resolve__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./lib/methods/_internal/resolve.js");
 // eslint-disable-line no-unused-vars



/**
 * executes a callback function on each element in an array
 *
 * if any elements are a `Promise`, they will first be resolved in parallel and then processed
 *
 * *Note*: if you'd rather resolve and process elements in series, consider using `series.forEachAF` or its alias, `io.forEachAF`
 *
 * @param {callback} callback function to execute for each element
 *
 * `callback` accepts three arguments:
 * - `currentValue` value of the current element being processed in the array
 * - `index`*`(optional)`* index of `currentValue` in the array
 * - `array`*`(optional)`* the array that forEachAF is being applied to
 * @param {Object=} thisArg value to use as `this` when executing `callback`
 * @returns {Promise.<undefined>} `Promise` that resolves to `undefined`
 * @example
 *
 * const promises = [1, 2].map(n => Promise.resolve(n));
 *
 *
 * AsyncAF(promises).forEachAF(el => {
 *   console.log(el); // logs 1 then 2
 * });
 * @since 3.0.0
 * @see forEach (alias)
 * @see {@link AsyncAF#series series.forEachAF}
 * @memberof AsyncAF#
 */

const forEachAF = function forEachAF(callback) {
  let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  return this.then(arr => {
    if (!Object(_internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_1__["default"])(arr)) throw TypeError("forEachAF cannot be called on ".concat(arr, ", only on an Array or array-like Object"));
    if (typeof callback !== 'function') throw TypeError("".concat(callback, " is not a function"));
    return (this.inSeries ? Object(_internal_resolve__WEBPACK_IMPORTED_MODULE_2__["serial"])(arr).then(arr => arr.reduce((expr, el, i, arr) => expr.then(() => Promise.resolve(callback.call(thisArg, el, i, arr))), Promise.resolve())) : Object(_internal_resolve__WEBPACK_IMPORTED_MODULE_2__["parallel"])(arr, callback, thisArg)).then(() => {});
  });
};

/* harmony default export */ __webpack_exports__["default"] = (forEachAF);

/***/ }),

/***/ "./lib/methods/arrays/includesAF.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./lib/methods/_internal/permissiveIsArrayLike.js");
/* harmony import */ var _internal_resolve__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./lib/methods/_internal/resolve.js");



const sameValueZero = (a, b) => a === b || Number.isNaN(a) && Number.isNaN(b);
/**
 * determines whether an array, string, or array-like object includes a certain element or string, returning true or false as appropriate
 *
 * *Note*: when called on an array or array-like object, `includesAF` is run in parallel and all elements will be resolved even if one of the first few elements is a match; if this behavior is not desireable, consider using `series.includesAF` or its alias, `io.includesAF`
 *
 * @param {any} searchItem the element or string to search for
 * @param {Number=} fromIndex the index at which to begin searching for `searchItem`; a negative value searches from the index of `array/string.length - fromIndex`; defaults to `0`
 * @returns {Promise.<Boolean>} `Promise` that resolves to `true` if `searchItem` is found; otherwise, `false`
 * @example
 *
 * // includesAF on an array of promises
 * const nums = [1, 2, 3].map(n => Promise.resolve(n));
 *
 * AsyncAF(nums).includesAF(2); // Promise that resolves to true
 *
 * AsyncAF(nums).includesAF(5); // Promise that resolves to false
 *
 * AsyncAF(nums).includesAF(1, 1); // Promise that resolves to false
 *
 * AsyncAF(nums).includesAF(3, -1); // Promise that resolves to true
 *
 * // includesAF on a promise-wrapped string
 * const string = Promise.resolve('test string');
 *
 * AsyncAF(string).includesAF('test'); // Promise that resolves to true
 *
 * AsyncAF(string).includesAF('nope'); // Promise that resolves to false
 *
 * AsyncAF(string).includesAF('test', 5); // Promise that resolves to false
 *
 * AsyncAF(string).includesAF('string', -6); // Promise that resolves to true
 *
 * // includesAF on an array-like object
 * (async function () {
 *   if (await AsyncAF(arguments).includesAF(2)) {
 *     console.log('2 is included');
 *   }
 * })(1, 2, 3); // logs '2 is included'
 *
 * @since 3.4.0
 * @see includes (alias)
 * @see {@link AsyncAF#series series.includesAF}
 * @memberof AsyncAF#
 */


const includesAF = function includesAF(searchItem) {
  let fromIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return this.then(arrOrStr => {
    if (!Object(_internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_0__["default"])(arrOrStr)) throw TypeError("includesAF cannot be called on ".concat(arrOrStr, ", only on an Array, String, or array-like Object"));
    const length = arrOrStr.length >>> 0;
    const fromIdx = fromIndex | 0;
    return typeof arrOrStr === 'string' ? arrOrStr.includes(searchItem, fromIdx) : this.inSeries ? (length || false) && function seriesIncludesAF(i) {
      return Promise.resolve(arrOrStr[i]).then(el => {
        if (sameValueZero(el, searchItem)) return true;
        if (i >= length - 1) return false;
        return seriesIncludesAF(i + 1);
      });
    }(Math.max(fromIdx >= 0 ? fromIdx : length - Math.abs(fromIdx), 0)) : Object(_internal_resolve__WEBPACK_IMPORTED_MODULE_1__["parallel"])(arrOrStr).then(arr => arr.includes(searchItem, fromIdx));
  });
};

/* harmony default export */ __webpack_exports__["default"] = (includesAF);

/***/ }),

/***/ "./lib/methods/arrays/indexOfAF.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./lib/methods/_internal/permissiveIsArrayLike.js");
/* harmony import */ var _internal_resolve__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./lib/methods/_internal/resolve.js");


/**
 * resolves to the first index of the specified element or string in an array, string, or array-like object, starting the search at `fromIndex`; if the value is not found, resolves to `-1`
 *
 * *Note*: when called on an array or array-like object, `indexOfAF` is run in parallel and all elements will be resolved even if one of the first few indices is a match; if this behavior is not desireable, consider using `series.indexOfAF` or its alias, `io.indexOfAF`
 *
 * @param {any} searchItem the element or string to search for
 * @param {Number=} fromIndex the index at which to begin searching for `searchItem`; a negative value searches from the index of `array/string.length - fromIndex`; defaults to `0`
 * @returns {Promise.<Number>} `Promise` that resolves to the index of `searchItem` if found; otherwise, `-1`
 * @example
 *
 * // indexOfAF on an array of promises
 * const nums = [1, 2, 3].map(n => Promise.resolve(n));
 *
 * AsyncAF(nums).indexOfAF(2); // Promise that resolves to 1
 *
 * AsyncAF(nums).indexOfAF(5); // Promise that resolves to -1
 *
 * AsyncAF(nums).indexOfAF(1, 1); // Promise that resolves to -1
 *
 * AsyncAF(nums).indexOfAF(3, -1); // Promise that resolves to 2
 *
 * // indexOfAF on a promise-wrapped string
 * const string = Promise.resolve('test string');
 *
 * AsyncAF(string).indexOfAF('test'); // Promise that resolves to 0
 *
 * AsyncAF(string).indexOfAF('nope'); // Promise that resolves to -1
 *
 * AsyncAF(string).indexOfAF('test', 5); // Promise that resolves to -1
 *
 * AsyncAF(string).indexOfAF('string', -6); // Promise that resolves to 5
 *
 * // indexOfAF on an array-like object
 * (async function () {
 *   if (await AsyncAF(arguments).indexOfAF(2) > -1) {
 *     console.log('2 is included');
 *   }
 * })(1, 2, 3); // logs '2 is included'
 *
 * @since 3.5.0
 * @see indexOf (alias)
 * @see {@link AsyncAF#series series.indexOfAF}
 * @memberof AsyncAF#
 */

const indexOfAF = function indexOfAF(searchItem) {
  let fromIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return this.then(arrOrStr => {
    if (!Object(_internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_0__["default"])(arrOrStr)) throw TypeError("indexOfAF cannot be called on ".concat(arrOrStr, ", only on an Array, String, or array-like Object"));
    const length = arrOrStr.length >>> 0;
    const fromIdx = fromIndex | 0;
    return typeof arrOrStr === 'string' ? arrOrStr.indexOf(searchItem, fromIdx) : this.inSeries ? function seriesIndexOfAF(i) {
      return Promise.resolve(arrOrStr[i]).then(el => {
        if (i in arrOrStr && el === searchItem) return i;
        if (i >= length - 1) return -1;
        return seriesIndexOfAF(i + 1);
      });
    }(Math.max(fromIdx >= 0 ? fromIdx : length - Math.abs(fromIdx), 0)) : Object(_internal_resolve__WEBPACK_IMPORTED_MODULE_1__["parallel"])(arrOrStr).then(arr => arr.indexOf(searchItem, fromIdx));
  });
};

/* harmony default export */ __webpack_exports__["default"] = (indexOfAF);

/***/ }),

/***/ "./lib/methods/arrays/joinAF.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./lib/methods/_internal/permissiveIsArrayLike.js");
/* harmony import */ var _internal_resolve__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./lib/methods/_internal/resolve.js");


/**
 * joins all elements of an array or array-like object into a string and resolves to that string
 *
 * @param {any} separator the string that separates each element in the resulting string; defaults to `','`; non-string separators will be converted to strings if necessary; if `separator` is an empty string `''`, the array elements are joined without any characters between them
 * @returns {Promise.<String>} `Promise` that resolves to a string with all array elements joined; if array.length is `0`, an empty string `''` is returned
 * @example
 *
 * const animals = ['cow', 'chicken', 'cat', 'dog'].map(a => Promise.resolve(a));
 *
 * // joinAF separator defaults to ','
 * AsyncAF(animals).joinAF(); // Promise that resolves to 'cow,chicken,cat,dog'
 *
 * // specifying separator
 * AsyncAF(animals).joinAF(' & '); // Promise that resolves to 'cow & chicken & cat & dog'
 *
 * // a non-string separator will be converted to a string
 * AsyncAF(animals).joinAF(2); // Promise that resolves to 'cow2chicken2cat2dog'
 *
 * // empty string separator
 * AsyncAF(animals).joinAF(''); // Promise that resolves to 'cowchickencatdog'
 *
 * // joining an empty array resolves to an empty string
 * AsyncAF([]).joinAF('+'); // Promise that resolves to ''
 *
 * // joinAF on an array-like object
 * (async function () {
 *  const list = await AsyncAF(arguments).joinAF(' - ');
 *  console.log(`Shopping List: ${list}`);
 * })('eggs', 'milk', 'butter', 'pancake mix');
 * // Shopping List: eggs - milk - butter - pancake mix
 *
 * @since 3.6.0
 * @see join (alias)
 * @memberof AsyncAF#
 */

const joinAF = function joinAF() {
  let separator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ',';
  return this.then(arr => {
    if (!Object(_internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_0__["default"])(arr)) throw TypeError("joinAF cannot be called on ".concat(arr, ", only on an Array or array-like Object"));
    return Object(_internal_resolve__WEBPACK_IMPORTED_MODULE_1__["parallel"])(arr).then(arr => arr.join(separator));
  });
};

Object.defineProperty(joinAF, 'length', {
  value: 1
});
/* harmony default export */ __webpack_exports__["default"] = (joinAF);

/***/ }),

/***/ "./lib/methods/arrays/lastIndexOfAF.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./lib/methods/_internal/permissiveIsArrayLike.js");
/* harmony import */ var _internal_resolve__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./lib/methods/_internal/resolve.js");


/**
 * resolves to the last index of the specified element or string, searching backwards in an array, string, or array-like object; `fromIndex` offsets the start of the search; if the value is not found, resolves to `-1`
 *
 * *Note*: when called on an array or array-like object, `lastIndexOfAF` is run in parallel and all elements will be resolved even if one of the last few indices is a match; if this behavior is not desireable, consider using `series.lastIndexOfAF` or its alias, `io.lastIndexOfAF`
 *
 * @param {any} searchItem the element or string to search for
 * @param {Number=} fromIndex the index at which to begin searching backwards for `searchItem`; a negative value searches from the index of `array/string.length - fromIndex`; defaults to `array/string.length - 1`
 * @returns {Promise.<Number>} `Promise` that resolves to the last index of `searchItem` if found; otherwise, `-1`
 * @example
 *
 * // lastIndexOfAF on an array of promises
 * const nums = [1, 1, 2, 2, 3, 3].map(n => Promise.resolve(n));
 *
 * AsyncAF(nums).lastIndexOfAF(2); // Promise that resolves to 3
 *
 * AsyncAF(nums).lastIndexOfAF(5); // Promise that resolves to -1
 *
 * AsyncAF(nums).lastIndexOfAF(2, -4); // Promise that resolves to 2
 *
 * AsyncAF(nums).lastIndexOfAF(3, -3); // Promise that resolves to -1
 *
 * // lastIndexOfAF on a promise-wrapped string
 * const string = Promise.resolve('test string to test');
 *
 * AsyncAF(string).lastIndexOfAF('test'); // Promise that resolves to 15
 *
 * AsyncAF(string).lastIndexOfAF('nope'); // Promise that resolves to -1
 *
 * AsyncAF(string).lastIndexOfAF('test', -5); // Promise that resolves to 0
 *
 * AsyncAF(string).lastIndexOfAF('to', -7); // Promise that resolves to -1
 *
 * // lastIndexOfAF on an array-like object
 * (async function () {
 *   const lastIndexOf2 = await AsyncAF(arguments).lastIndexOfAF(2);
 *   console.log(`the last index of 2 in the arguments array-like object is ${lastIndexOf2}`)
 * })(1, 1, 2, 2, 3, 3); // the last index of 2 in the arguments array-like object is 3
 *
 * @since 3.6.0
 * @see lastIndexOf (alias)
 * @see {@link AsyncAF#series series.lastIndexOfAF}
 * @memberof AsyncAF#
 */

const lastIndexOfAF = function lastIndexOfAF(searchItem) {
  let fromIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  return this.then(arrOrStr => {
    if (!Object(_internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_0__["default"])(arrOrStr)) throw TypeError("lastIndexOfAF cannot be called on ".concat(arrOrStr, ", only on an Array, String, or array-like Object"));
    const len = arrOrStr.length >>> 0;
    let fromIdx = Number(fromIndex);
    if (Number.isNaN(fromIdx)) fromIdx = len - 1;
    return typeof arrOrStr === 'string' ? arrOrStr.lastIndexOf(searchItem, fromIdx) : this.inSeries ? function seriesLastIndexOfAF(i) {
      return Promise.resolve(arrOrStr[i]).then(el => {
        if (i in arrOrStr && el === searchItem) return i;
        if (i <= 0) return -1;
        return seriesLastIndexOfAF(i - 1);
      });
    }(Math.min(fromIdx >= 0 ? fromIdx : Math.max(len - Math.abs(fromIdx), 0), len - 1)) : Object(_internal_resolve__WEBPACK_IMPORTED_MODULE_1__["parallel"])(arrOrStr).then(arr => arr.lastIndexOf(searchItem, fromIdx));
  });
};

/* harmony default export */ __webpack_exports__["default"] = (lastIndexOfAF);

/***/ }),

/***/ "./lib/methods/arrays/mapAF.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_commonCallback__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./lib/methods/_internal/commonCallback.js");
/* harmony import */ var _internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./lib/methods/_internal/permissiveIsArrayLike.js");
/* harmony import */ var _internal_promiseAllWithHoles__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./lib/methods/_internal/promiseAllWithHoles.js");
/* harmony import */ var _internal_resolve__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./lib/methods/_internal/resolve.js");
 // eslint-disable-line no-unused-vars




/**
 * creates a new `Array` with the results of calling a provided function on every element in the original array
 *
 * if any elements are a `Promise`, they will first be resolved in parallel and then processed
 *
 * *Note*: if you'd rather resolve and process elements in series, consider using `series.mapAF` or its alias, `io.mapAF`
 *
 * @param {callback} callback function that produces an element of the new `Array`
 *
 * `callback` accepts three arguments:
 * - `currentValue` value of the current element being processed in the array
 * - `index`*`(optional)`* index of `currentValue` in the array
 * - `array`*`(optional)`* the array that mapAF is being applied to
 * @param {Object=} thisArg value to use as `this` when executing `callback`
 * @returns {Promise.<Array>} `Promise` that resolves to a new `Array` with each element being the result of calling `callback` on each original element
 * @example
 *
 * const promises = [1, 2].map(n => Promise.resolve(n));
 *
 *
 * // basic usage
 * const doubled = AsyncAF(promises).mapAF(el => el * 2);
 *
 * console.log(doubled); // Promise that resolves to [2, 4]
 *
 * AsyncAF.logAF(doubled); // logs [2, 4]
 *
 *
 * // using .then
 * AsyncAF(promises).mapAF(el => el * 3).then(tripled => {
 *   console.log(tripled); // logs [3, 6]
 * });
 *
 *
 * // inside an async function
 * (async () => {
 *   const quadrupled = await AsyncAF(promises).mapAF(
 *     el => el * 4
 *   );
 *   console.log(quadrupled); // logs [4, 8]
 * })();
 * @since 3.0.0
 * @see map (alias)
 * @see {@link AsyncAF#series series.mapAF}
 * @memberof AsyncAF#
 */

const mapAF = function mapAF(callback) {
  let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  return this.then(arr => {
    if (!Object(_internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_1__["default"])(arr)) throw TypeError("mapAF cannot be called on ".concat(arr, ", only on an Array or array-like Object"));
    if (typeof callback !== 'function') throw TypeError("".concat(callback, " is not a function"));
    return this.inSeries ? Object(_internal_resolve__WEBPACK_IMPORTED_MODULE_3__["serial"])(arr).then(arr => arr.reduce((map, el, i, arr) => map.then(map => {
      map[i] = Promise.resolve(callback.call(thisArg, el, i, arr));
      return Object(_internal_promiseAllWithHoles__WEBPACK_IMPORTED_MODULE_2__["default"])(map);
    }), Promise.resolve(Array(arr.length >>> 0)))) : Object(_internal_resolve__WEBPACK_IMPORTED_MODULE_3__["parallel"])(arr, callback, thisArg);
  });
};

/* harmony default export */ __webpack_exports__["default"] = (mapAF);

/***/ }),

/***/ "./lib/methods/arrays/reduceAF.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// CONCATENATED MODULE: ./lib/methods/_internal/reduceCallback.js
/* eslint-disable no-unused-vars, valid-jsdoc */

/**
 * @typedef {callback} _
 * @param {?} accumulator
 * @param {?} currentValue
 * @param {Number=} index
 * @param {[]=} array
 */
function reduceCallback_callback(accumulator, currentValue, index, array) {}

/* harmony default export */ var reduceCallback = (reduceCallback_callback);
// EXTERNAL MODULE: ./lib/methods/_internal/permissiveIsArrayLike.js
var permissiveIsArrayLike = __webpack_require__("./lib/methods/_internal/permissiveIsArrayLike.js");

// EXTERNAL MODULE: ./lib/methods/_internal/resolve.js
var resolve = __webpack_require__("./lib/methods/_internal/resolve.js");

// CONCATENATED MODULE: ./lib/methods/arrays/reduceAF.js
 // eslint-disable-line no-unused-vars



/* eslint-disable prefer-rest-params */

/**
 * applies a function against an accumulator and each element in an array (from left to right) to reduce it to a single value
 *
 * if any elements are a `Promise`, they will first be resolved in parallel and then processed in series
 *
 * *Note*: if this behavior is not desirable, consider using `series.reduceAF` or its alias, `io.reduceAF`; that way, if any elements are a `Promise`, they will both be resolved in series _and_ processed in series
 *
 * @param {callback} callback function to execute for each element
 *
 * `callback` accepts up to four arguments:
 * - `accumulator` accumulates the callback's return values; the accumulated value previously returned in the last invocation of the callback, or initialValue, if supplied
 * - `currentValue` value of the current element being processed in the array
 * - `index`*`(optional)`* index of `currentValue` in the array
 * - `array`*`(optional)`* the array that `reduceAF` is being applied to
 * @param {any=} initialValue value to use as the first argument to the first call of the callback; if no initial value is supplied, the first element in the array will be used; note: calling reduceAF on an empty array with no initial value will throw an error
 * @returns {Promise.<any>} `Promise` that resolves to the reduced value
 * @example
 *
 * const promises = [1, 2, 3].map(n => Promise.resolve(n));
 *
 *
 * // basic usage
 * const sum = AsyncAF(promises).reduceAF((sum, num) => sum + num);
 *
 * console.log(sum); // Promise that resolves to 6
 *
 * AsyncAF.logAF(sum); // logs 6
 *
 *
 * // using .then
 * AsyncAF(promises).reduceAF((sum, num) => sum + num).then(sum => {
 *   console.log(sum); // logs 6
 * });
 *
 *
 * // inside an async function
 * (async () => {
 *   const sum = await AsyncAF(promises).reduceAF((sum, num) => sum + num);
 *   console.log(sum); // logs 6
 * })();
 *
 *
 * // using an initial value
 * AsyncAF(promises).reduceAF((sum, num) => sum + num, 12) // Promise that resolves to 18
 * @since 3.1.0
 * @see reduce (alias)
 * @see {@link AsyncAF#series series.reduceAF}
 * @memberof AsyncAF#
 */

const reduceAF_reduceAF = function reduceAF(callback
/* , initialValue */
) {
  return this.then(arr => {
    if (!Object(permissiveIsArrayLike["default"])(arr)) throw TypeError("reduceAF cannot be called on ".concat(arr, ", only on an Array or array-like Object"));
    if (typeof callback !== 'function') throw TypeError("".concat(callback, " is not a function"));
    const length = arr.length >>> 0;
    if (!length && arguments.length === 1) throw TypeError('reduceAF cannot be called on an empty array without an initial value');
    if (!length) return arguments[1];

    const hole = i => !(i in arr);

    let i = 0;
    let acc;

    if (arguments.length === 2) {
      [, acc] = arguments;
    } else {
      while (hole(i)) i++;

      acc = arr[i++];
    }

    return (this.inSeries ? resolve["serial"] : resolve["parallel"])(arr).then(arr => {
      const reduceAF = (acc, i) => Promise.resolve(acc).then(acc => Promise.resolve(!hole(i) ? callback(acc, arr[i], i, arr) : acc).then(acc => i === length - 1 ? acc : reduceAF(acc, i + 1)));

      return reduceAF(acc, i);
    });
  });
};

/* harmony default export */ var arrays_reduceAF = __webpack_exports__["default"] = (reduceAF_reduceAF);

/***/ }),

/***/ "./lib/methods/arrays/someAF.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_commonCallback__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./lib/methods/_internal/commonCallback.js");
/* harmony import */ var _internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./lib/methods/_internal/permissiveIsArrayLike.js");
/* harmony import */ var _internal_resolve__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./lib/methods/_internal/resolve.js");
 // eslint-disable-line no-unused-vars



/**
 * tests whether at least one element in the array passes the test implemented by the provided callback function
 *
 * if any elements are a `Promise`, they will first be resolved in parallel and then tested
 *
 * *Note*: since `someAF` is run in parallel, `callback` will be run on all elements even if one of the first few elements passes the test; if this behavior is not desireable, consider using `series.someAF` or its alias, `io.someAF`
 *
 * @param {callback} callback function that tests each element of the array
 *
 * `callback` accepts three arguments:
 * - `currentValue` value of the current element being processed in the array
 * - `index`*`(optional)`* index of `currentValue` in the array
 * - `array`*`(optional)`* the array that `someAF` is being applied to
 * @param {Object=} thisArg value to use as `this` when executing `callback`
 * @returns {Promise.<Boolean>} `Promise` that resolves to `true` if the callback function returns a truthy value for any array element; otherwise, `false`
 * @example
 *
 * const promises = [1, 2, 3].map(n => Promise.resolve(n));
 *
 *
 * // basic usage
 * const someAreEven = AsyncAF(promises).someAF(n => n % 2 === 0);
 *
 * console.log(someAreEven); // Promise that resolves to true
 *
 * AsyncAF.logAF(someAreEven); // logs true
 *
 *
 * // using .then
 * AsyncAF(promises).someAF(n => n % 2 === 0).then(someAreEven => {
 *   console.log(someAreEven); // logs true
 * });
 *
 *
 * // inside an async function
 * (async () => {
 *   const someAreStrings = await AsyncAF(promises).someAF(
 *     n => typeof n === 'string'
 *   );
 *   console.log(someAreStrings); // logs false
 * })();
 * @since 3.3.0
 * @see some (alias)
 * @see {@link AsyncAF#series series.someAF}
 * @memberof AsyncAF#
 */

const someAF = function someAF(callback) {
  let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  return this.then(arr => {
    if (!Object(_internal_permissiveIsArrayLike__WEBPACK_IMPORTED_MODULE_1__["default"])(arr)) throw TypeError("someAF cannot be called on ".concat(arr, ", only on an Array or array-like Object"));
    if (typeof callback !== 'function') throw TypeError("".concat(callback, " is not a function"));
    const length = arr.length >>> 0;
    return this.inSeries ? (length || false) && function seriesSomeAF(arr, i) {
      const hole = !(i in arr);
      return Promise.resolve(arr[i]).then(el => {
        arr[i] = el;
        return Promise.resolve(!hole && callback.call(thisArg, el, i, arr)).then(bool => {
          if (bool && !hole) return true;
          if (i === length - 1) return false;
          return seriesSomeAF(arr, i + 1);
        });
      });
    }(Array.prototype.slice.call(arr), 0) : Object(_internal_resolve__WEBPACK_IMPORTED_MODULE_2__["parallel"])(arr, callback, thisArg).then(bools => bools.some(Boolean));
  });
};

/* harmony default export */ __webpack_exports__["default"] = (someAF);

/***/ }),

/***/ "./lib/methods/other/logAF.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// CONCATENATED MODULE: ./lib/methods/_internal/logging.js
/* eslint-disable no-console */
const wrappedLog = function wrappedLog() {
  console && console.log && console.log(...arguments);
};

const wrappedWarn = function wrappedWarn() {
  console && console.warn && console.warn(...arguments);
};


// CONCATENATED MODULE: ./lib/methods/other/logAfHelpers/logAfOptions.js

/**
 * Sets logging options for {@link AsyncAF#logAF logAF}
 *
 * accepts an options object with the following optional properties:
 * - label (`Boolean`) - set to `false` to disable logging the location of calls to logAF
 * - duration (`Boolean`) - set to `false` to disable logging the time it takes (in secs) to complete each call to logAF
 * - labelFormat (`String`|`Function`) - alters the format of logAF labels; choose between `file` (*default*), `path`, `parent`, `arrow`, or a custom string or function
 *
 * ```js
 * const promise = new Promise(resolve => setTimeout(
 *   () => resolve(1), 1000)
 * );
 * ```
 * **default logging**
 * ```js
 * logAF(promise, 2);
 *
 * // @filename.js:24:1:
 * // 1 2
 * // in 0.998 secs
 * ```
 * **turn off label**
 * ```js
 * logAF.options({ label: false });
 * logAF(promise, 2);
 *
 * // 1 2
 * // in 0.999 secs
 * ```
 * **turn off duration**
 * ```js
 * logAF.options({ duration: false });
 * logAF(promise, 2);
 *
 * // @filename.js:24:1:
 * // 1 2
 * ```
 * **change labelFormat**
 *
 * &#9679; file (*default*)
 *
 * ```js
 * logAF.options({ labelFormat: 'file' });
 * logAF(promise, 2);
 *
 * // @filename.js:24:1:
 * // 1 2
 * // in 0.998 secs
 * ```
 * &#9679; path
 *
 * ```js
 * logAF.options({ labelFormat: 'path' });
 * logAF(promise, 2);
 *
 * // @/Path/to/current/directory/filename.js:24:1:
 * // 1 2
 * // in 0.997 secs
 * ```
 * &#9679; parent
 *
 * ```js
 * logAF.options({ labelFormat: 'parent' });
 * logAF(promise, 2);
 *
 * // @parentDirectory/filename.js:24:1:
 * // 1 2
 * // in 0.998 secs
 * ```
 * &#9679; arrow
 *
 * ```js
 * logAF.options({ labelFormat: 'arrow' });
 * logAF(promise, 2);
 *
 * // ========================> 1 2
 * // in 0.999 secs
 * ```
 *
 * &#9679; custom (create your own labelFormat)
 *  - to set a custom labelFormat, set it to any string other than the formats above
 *
 * ```js
 * logAF.options({
 *  labelFormat: 'I logged this:'
 * });
 * logAF(promise, 2);
 *
 * // I logged this: 1 2
 * // in 1.000 secs
 * ```
 *
 * - labelFormat also accepts a function with access to an object containing the location variables `file`, `path`, `parent`, `arrow`, `line`, and `col`
 *
 * e.g., to set the labelFormat to `file:line:col =>`:
 * ```js
 * logAF.options({
 *  labelFormat: ({file, line, col}) => `${file}:${line}:${col} =>`
 * });
 * logAF(promise, 2);
 *
 * // filename.js:24:1 => 1 2
 * // in 0.998 secs
 * ```
 *
 * and just to demonstrate all the location variables in one custom format:
 * ```js
 * logAF.options({
 *   labelFormat: ({arrow, line, col, parent, file, path}) =>
 * `${arrow}
 * line: ${line}
 * col: ${col}
 * parent: ${parent}
 * file: ${file}
 * path: ${path}
 * `
 * });
 * logAF(promise, 2);
 *
 * // ========================>
 * // line: 24
 * // col: 1
 * // parent: parentDirectory/
 * // file: filename.js
 * // path: /Full/path/to/the/parentDirectory/
 * // 1 2
 * // in 0.998 secs
 * ```
 *
 * to reset `logAF.options` to its default values, call `logAF.options.reset`
 * ```js
 * logAF.options.reset();
 *
 * // options are now:
 * // label: true,
 * // duration: true,
 * // labelFormat: 'file'
 * ```
 *
 * @static
 * @param {Object} options the options for logAF
 * @param {Boolean} [options.label=true] set to false to turn off the label
 * @param {Boolean} [options.duration=true] set to false to turn off duration
 * @param {String|Function} [options.labelFormat=file] see examples for sample label formats
 * @returns {undefined} sets the options for logAF
 * @see {@link AsyncAF#logAF logAF}
 * @see logAF.options.reset to reset options to default
 * @memberof AsyncAF
 * @alias AsyncAF#logAF_options
 */

const logAfOptions_logAfOptions = function logAfOptions() {
  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const {
    label,
    duration,
    labelFormat
  } = options;
  if (typeof label === 'boolean') other_logAF.label = label;
  if (typeof duration === 'boolean') other_logAF.duration = duration;
  if (labelFormat) if (typeof labelFormat === 'string' || typeof labelFormat === 'function') other_logAF.labelFormat = labelFormat;else other_logAF.wrappedWarn('Warning: logAF labelFormat option must be set to \'file\' (default), \'path\', \'parent\', \'arrow\', or a custom string or function\n');
};

/* harmony default export */ var logAfHelpers_logAfOptions = (logAfOptions_logAfOptions);
// CONCATENATED MODULE: ./lib/methods/other/logAfHelpers/customFormat.js
function _templateObject4() {
  const data = _taggedTemplateLiteral(["/"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  const data = _taggedTemplateLiteral(["/"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  const data = _taggedTemplateLiteral(["/"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  const data = _taggedTemplateLiteral([":"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

const custom = (format, fullPath, arrow) => {
  if (typeof format === 'string') return format;
  let [path, line, col] = fullPath.split(_templateObject()); // eslint-disable-line prefer-const

  path = path.split(_templateObject2());
  const file = path.pop();
  path = path.join(_templateObject3());
  const parent = "".concat(path.split(_templateObject4()).pop(), "/");
  path += '/';
  return format({
    path,
    line,
    col,
    file,
    parent,
    arrow
  });
};

/* harmony default export */ var customFormat = (custom);
// CONCATENATED MODULE: ./lib/methods/other/logAfHelpers/setFormat.js
function setFormat_templateObject4() {
  const data = setFormat_taggedTemplateLiteral(["/"]);

  setFormat_templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function setFormat_templateObject3() {
  const data = setFormat_taggedTemplateLiteral(["/"]);

  setFormat_templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function setFormat_templateObject2() {
  const data = setFormat_taggedTemplateLiteral(["/"]);

  setFormat_templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function setFormat_templateObject() {
  const data = setFormat_taggedTemplateLiteral(["\n"], ["\\n"]);

  setFormat_templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function setFormat_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }



const setFormat = labelFormat => {
  const error = new Error();
  /* istanbul ignore if */

  if (!error.stack) return '';
  const [targetLine] = error.stack.split(setFormat_templateObject()).filter((_, i, lines) => /logAF(?:\s+|\s+\[.+\]\s+)\(/.test(lines[i ? i - 1 : i]) || /logAfStub(?:\s+|\s+\[.+\]\s+)\(/.test(lines[i]));
  const fullPath = targetLine.slice(targetLine.indexOf(setFormat_templateObject2())).replace(')', '');
  const target = fullPath.lastIndexOf(setFormat_templateObject3());
  const formats = {
    file() {
      return "@".concat(fullPath.slice(target + 1), ":\n");
    },

    path() {
      return "@".concat(fullPath, ":\n");
    },

    parent() {
      const start = fullPath.slice(0, target).lastIndexOf(setFormat_templateObject4()) + 1;
      return "@".concat(fullPath.slice(start), ":\n");
    },

    arrow() {
      return '========================>';
    }

  };
  return formats[labelFormat] ? formats[labelFormat]() : customFormat(labelFormat, fullPath, formats.arrow());
};

/* harmony default export */ var logAfHelpers_setFormat = (setFormat);
// EXTERNAL MODULE: ./lib/methods/_internal/nameFunction.js
var nameFunction = __webpack_require__("./lib/methods/_internal/nameFunction.js");

// CONCATENATED MODULE: ./lib/methods/other/logAF.js




/**
 * logs items to the console in the order given
 *
 * if any items are a promise, they will first be resolved in parallel and then logged
 *
 * ```js
 * import { logAF } from 'async-af';
 *
 * const promise = new Promise(resolve => setTimeout(
 *  () => resolve(2), 1000)
 * );
 *
 * logAF(1, promise, 3);
 *
 * // @filename.js:6:12:
 * // 1 2 3
 * // in 0.998 secs
 * ```
 *
 * **Note:** since logAF returns a promise, the items in the previous example would be logged *after* any synchronous calls to `console.log`
 *
 * to produce in-order logging with any surrounding calls to `console.log`, `await` logAF:
 * ```js
 * logAF.options({ label: false, duration: false });
 *
 * (async () => {
 *   console.log(1);
 *   // ...some code
 *   await logAF(promise);
 *   // ...some more code
 *   console.log(3);
 * })();
 *
 * // 1
 * // 2
 * // 3
 * ```
 *
 * **experimental feature**: the label may not work correctly in all environments; to turn the label off, set `label` to `false` in {@link AsyncAF#logAF_options logAF.options}, where you can also change the label's format
 *
 * @static
 * @param {any} items The items to print (log to the console)
 * @returns {Promise<undefined>} returns a `Promise` that logs items to the console
 * @see log (alias)
 * @see {@link AsyncAF#logAF_options logAF.options} to turn the label off or change its format
 * @see logAF.options.reset to reset options to default
 * @since 3.0.0
 * @memberof AsyncAF
 * @alias AsyncAF#logAF
 */

const logAF = function logAF() {
  for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {
    items[_key] = arguments[_key];
  }

  if (logAF.label) items.unshift(logAF.setFormat(logAF.labelFormat));
  const start = Date.now();
  return Promise.all(items).then(toLog => {
    if (logAF.duration) {
      const end = Date.now();
      const numberOf = ((end - start) / 1000).toFixed(3);
      toLog.push("\n in ".concat(numberOf, " secs"));
    }

    logAF.wrappedLog('', ...toLog);
  });
};

Object.defineProperties(logAF, {
  wrappedLog: {
    value: wrappedLog,
    writable: true
  },
  wrappedWarn: {
    value: wrappedWarn,
    writable: true
  },
  setFormat: {
    value: logAfHelpers_setFormat,
    writable: true
  },
  options: {
    value: logAfHelpers_logAfOptions,
    writable: true
  }
});
(logAF.options.reset = function logAfOptionsReset() {
  logAF.label = true;
  logAF.labelFormat = 'file';
  logAF.duration = true;
})();
/* harmony default export */ var other_logAF = __webpack_exports__["default"] = (Object(nameFunction["default"])(logAF, 'logAF'));

/***/ }),

/***/ "./lib/methods/strings/splitAF.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * splits a string into an array of substrings, using a specified separator to determine where to make each split
 *
 * @param {String|RegExp=} separator a string or regular expression that denotes the points at which each split should occur
 * - if a plain-text separator contains more than one character, the entire separator must be found to represent a split point
 * - if separator is omitted or does not occur in the string, the array returned will contain one element consisting of the entire string
 * - if separator is an empty string, the string is converted to an array of individual characters
 * - if separator is a regular expression, the array returned will also contain any separators found as a result of matches within capturing parentheses
 * @param {Number=} limit integer specifying a limit on the number of elements to be included in the result; when provided, the string is split at each occurrence of the specified separator but stops including elements when the limit is reached (or the end of the string, if reached sooner); any left-over text is not included in the result
 * @returns {Promise.<String[]>} `Promise` that resolves to an array of strings, split at each point the separator occurs in the given string
 * @example
 *
 * // basic usage
 * const str = Promise.resolve('s; p; l; i; t');
 *
 * AsyncAF(str).splitAF('; '); // Promise that resolves to ['s', 'p', 'l', 'i', 't']
 *
 * // no separator specified or separator not found
 * const str = Promise.resolve('splat');
 *
 * AsyncAF(str).splitAF(); // Promise that resolves to ['splat']
 * AsyncAF(str).splitAF('n/a'); // Promise that resolves to ['splat']
 *
 * // split to individual characters
 * const str = Promise.resolve('splitAF');
 *
 * AsyncAF(str).splitAF(''); // Promise that resolves to ['s', 'p', 'l', 'i', 't', 'A', 'F']
 *
 * // split on a regular expression
 * const str = Promise.resolve('splittedAF');
 *
 * AsyncAF(str).splitAF(/sp|ted/); // Promise that resolves to ['', 'lit', 'AF']
 *
 * // and w/ capturing parentheses
 *
 * AsyncAF(str).splitAF(/(lit|AF)/); // Promise that resolves to ['sp', 'lit', '', 'AF', '']
 *
 * // setting limit
 * const str = Promise.resolve('splitted');
 *
 * AsyncAF(str).splitAF('', 5); // Promise that resolves to ['s', 'p', 'l', 'i', 't']
 * AsyncAF(str).splitAF('', 12); // Promise that resolves to ['s', 'p', 'l', 'i', 't', 't', 'e', 'd']
 * AsyncAF(str).splitAF('', 0); // Promise that resolves to []
 *
 * @since 5.1.0
 * @see split (alias)
 * @memberof AsyncAF#
 */
const splitAF = function splitAF() {
  let separator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
  let limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  return this.then(str => {
    if (typeof str !== 'string' || Array.isArray(str)) throw TypeError("splitAF may be called on a string but was called on ".concat(str));
    return String.prototype.split.call(str, separator, limit);
  });
};

/* harmony default export */ __webpack_exports__["default"] = (splitAF);

/***/ })

/******/ })["default"];
});
//# sourceMappingURL=index.js.map